var cr=Object.defineProperty;var h=(W,Y)=>cr(W,"name",{value:Y,configurable:!0});exports.id=457;exports.ids=[457];exports.modules={5186:(W,Y,E)=>{var P=E(3698),Z=E(2505),R=E(6417),y=Function.bind,M=y.bind(y);function S(J,I,ve){var L=M(R,null).apply(null,ve?[I,ve]:[I]);J.api={remove:L},J.remove=L,["before","error","after","wrap"].forEach(function(be){var de=ve?[I,be,ve]:[I,be];J[be]=J.api[be]=M(Z,null).apply(null,de)})}h(S,"bindApi");function z(){var J="h",I={registry:{}},ve=P.bind(null,I,J);return S(ve,I,J),ve}h(z,"HookSingular");function V(){var J={registry:{}},I=P.bind(null,J);return S(I,J),I}h(V,"HookCollection");var _=!1;function ie(){return _||(console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'),_=!0),V()}h(ie,"Hook"),ie.Singular=z.bind(),ie.Collection=V.bind(),W.exports=ie,W.exports.Hook=ie,W.exports.Singular=ie.Singular,W.exports.Collection=ie.Collection},2505:W=>{W.exports=Y;function Y(E,P,Z,R){var y=R;E.registry[Z]||(E.registry[Z]=[]),P==="before"&&(R=h(function(M,S){return Promise.resolve().then(y.bind(null,S)).then(M.bind(null,S))},"hook")),P==="after"&&(R=h(function(M,S){var z;return Promise.resolve().then(M.bind(null,S)).then(function(V){return z=V,y(z,S)}).then(function(){return z})},"hook")),P==="error"&&(R=h(function(M,S){return Promise.resolve().then(M.bind(null,S)).catch(function(z){return y(z,S)})},"hook")),E.registry[Z].push({hook:R,orig:y})}h(Y,"addHook")},3698:W=>{W.exports=Y;function Y(E,P,Z,R){if(typeof Z!="function")throw new Error("method for before hook must be a function");return R||(R={}),Array.isArray(P)?P.reverse().reduce(function(y,M){return Y.bind(null,E,M,y,R)},Z)():Promise.resolve().then(function(){return E.registry[P]?E.registry[P].reduce(function(y,M){return M.hook.bind(null,y,R)},Z)():Z(R)})}h(Y,"register")},6417:W=>{W.exports=Y;function Y(E,P,Z){if(!!E.registry[P]){var R=E.registry[P].map(function(y){return y.orig}).indexOf(Z);R!==-1&&E.registry[P].splice(R,1)}}h(Y,"removeHook")},1232:(W,Y,E)=>{"use strict";E.r(Y),E.d(Y,{GitHubApi:()=>ue,GitHubPullRequest:()=>tt,fromCommitFileStatus:()=>ur});function P(){return typeof navigator=="object"&&"userAgent"in navigator?navigator.userAgent:typeof process=="object"&&"version"in process?`Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`:"<environment undetectable>"}h(P,"getUserAgent");var Z=E(5186);/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */function R(r){return Object.prototype.toString.call(r)==="[object Object]"}h(R,"isObject");function y(r){var e,n;return R(r)===!1?!1:(e=r.constructor,e===void 0?!0:(n=e.prototype,!(R(n)===!1||n.hasOwnProperty("isPrototypeOf")===!1)))}h(y,"isPlainObject");function M(r){return r?Object.keys(r).reduce((e,n)=>(e[n.toLowerCase()]=r[n],e),{}):{}}h(M,"lowercaseKeys");function S(r,e){const n=Object.assign({},r);return Object.keys(e).forEach(a=>{y(e[a])?a in r?n[a]=S(r[a],e[a]):Object.assign(n,{[a]:e[a]}):Object.assign(n,{[a]:e[a]})}),n}h(S,"mergeDeep");function z(r){for(const e in r)r[e]===void 0&&delete r[e];return r}h(z,"removeUndefinedProperties");function V(r,e,n){if(typeof e=="string"){let[i,c]=e.split(" ");n=Object.assign(c?{method:i,url:c}:{url:i},n)}else n=Object.assign({},e);n.headers=M(n.headers),z(n),z(n.headers);const a=S(r||{},n);return r&&r.mediaType.previews.length&&(a.mediaType.previews=r.mediaType.previews.filter(i=>!a.mediaType.previews.includes(i)).concat(a.mediaType.previews)),a.mediaType.previews=a.mediaType.previews.map(i=>i.replace(/-preview/,"")),a}h(V,"merge");function _(r,e){const n=/\?/.test(r)?"&":"?",a=Object.keys(e);return a.length===0?r:r+n+a.map(i=>i==="q"?"q="+e.q.split("+").map(encodeURIComponent).join("+"):`${i}=${encodeURIComponent(e[i])}`).join("&")}h(_,"addQueryParameters");const ie=/\{[^}]+\}/g;function J(r){return r.replace(/^\W+|\W+$/g,"").split(/,/)}h(J,"removeNonChars");function I(r){const e=r.match(ie);return e?e.map(J).reduce((n,a)=>n.concat(a),[]):[]}h(I,"extractUrlVariableNames");function ve(r,e){return Object.keys(r).filter(n=>!e.includes(n)).reduce((n,a)=>(n[a]=r[a],n),{})}h(ve,"omit");function L(r){return r.split(/(%[0-9A-Fa-f]{2})/g).map(function(e){return/%[0-9A-Fa-f]/.test(e)||(e=encodeURI(e).replace(/%5B/g,"[").replace(/%5D/g,"]")),e}).join("")}h(L,"encodeReserved");function be(r){return encodeURIComponent(r).replace(/[!'()*]/g,function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})}h(be,"encodeUnreserved");function de(r,e,n){return e=r==="+"||r==="#"?L(e):be(e),n?be(n)+"="+e:e}h(de,"encodeValue");function Ue(r){return r!=null}h(Ue,"isDefined");function Fe(r){return r===";"||r==="&"||r==="?"}h(Fe,"isKeyOperator");function le(r,e,n,a){var i=r[n],c=[];if(Ue(i)&&i!=="")if(typeof i=="string"||typeof i=="number"||typeof i=="boolean")i=i.toString(),a&&a!=="*"&&(i=i.substring(0,parseInt(a,10))),c.push(de(e,i,Fe(e)?n:""));else if(a==="*")Array.isArray(i)?i.filter(Ue).forEach(function(d){c.push(de(e,d,Fe(e)?n:""))}):Object.keys(i).forEach(function(d){Ue(i[d])&&c.push(de(e,i[d],d))});else{const d=[];Array.isArray(i)?i.filter(Ue).forEach(function(p){d.push(de(e,p))}):Object.keys(i).forEach(function(p){Ue(i[p])&&(d.push(be(p)),d.push(de(e,i[p].toString())))}),Fe(e)?c.push(be(n)+"="+d.join(",")):d.length!==0&&c.push(d.join(","))}else e===";"?Ue(i)&&c.push(be(n)):i===""&&(e==="&"||e==="?")?c.push(be(n)+"="):i===""&&c.push("");return c}h(le,"getValues");function Qe(r){return{expand:We.bind(null,r)}}h(Qe,"parseUrl");function We(r,e){var n=["+","#",".","/",";","?","&"];return r.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g,function(a,i,c){if(i){let p="";const w=[];if(n.indexOf(i.charAt(0))!==-1&&(p=i.charAt(0),i=i.substr(1)),i.split(/,/g).forEach(function(F){var A=/([^:\*]*)(?::(\d+)|(\*))?/.exec(F);w.push(le(e,p,A[1],A[2]||A[3]))}),p&&p!=="+"){var d=",";return p==="?"?d="&":p!=="#"&&(d=p),(w.length!==0?p:"")+w.join(d)}else return w.join(",")}else return L(c)})}h(We,"expand");function Ne(r){let e=r.method.toUpperCase(),n=(r.url||"/").replace(/:([a-z]\w+)/g,"{$1}"),a=Object.assign({},r.headers),i,c=ve(r,["method","baseUrl","url","headers","request","mediaType"]);const d=I(n);n=Qe(n).expand(c),/^http/.test(n)||(n=r.baseUrl+n);const p=Object.keys(r).filter(A=>d.includes(A)).concat("baseUrl"),w=ve(c,p);if(!/application\/octet-stream/i.test(a.accept)&&(r.mediaType.format&&(a.accept=a.accept.split(/,/).map(A=>A.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,`application/vnd$1$2.${r.mediaType.format}`)).join(",")),r.mediaType.previews.length)){const A=a.accept.match(/[\w-]+(?=-preview)/g)||[];a.accept=A.concat(r.mediaType.previews).map(G=>{const X=r.mediaType.format?`.${r.mediaType.format}`:"+json";return`application/vnd.github.${G}-preview${X}`}).join(",")}return["GET","HEAD"].includes(e)?n=_(n,w):"data"in w?i=w.data:Object.keys(w).length?i=w:a["content-length"]=0,!a["content-type"]&&typeof i<"u"&&(a["content-type"]="application/json; charset=utf-8"),["PATCH","PUT"].includes(e)&&typeof i>"u"&&(i=""),Object.assign({method:e,url:n,headers:a},typeof i<"u"?{body:i}:null,r.request?{request:r.request}:null)}h(Ne,"parse");function Ze(r,e,n){return Ne(V(r,e,n))}h(Ze,"endpointWithDefaults");function De(r,e){const n=V(r,e),a=Ze.bind(null,n);return Object.assign(a,{DEFAULTS:n,defaults:De.bind(null,n),merge:V.bind(null,n),parse:Ne})}h(De,"withDefaults");const je=`octokit-endpoint.js/6.0.12 ${P()}`,Ge=De(null,{method:"GET",baseUrl:"https://api.github.com",headers:{accept:"application/vnd.github.v3+json","user-agent":je},mediaType:{format:"",previews:[]}});var ce=E(2781),se=E(3685),ae=E(7310),D=E(7347),Re=E(5687),xe=E(9796);const Le=ce.Readable,Pe=Symbol("buffer"),Ye=Symbol("type");class O{constructor(){this[Ye]="";const e=arguments[0],n=arguments[1],a=[];let i=0;if(e){const d=e,p=Number(d.length);for(let w=0;w<p;w++){const F=d[w];let A;F instanceof Buffer?A=F:ArrayBuffer.isView(F)?A=Buffer.from(F.buffer,F.byteOffset,F.byteLength):F instanceof ArrayBuffer?A=Buffer.from(F):F instanceof O?A=F[Pe]:A=Buffer.from(typeof F=="string"?F:String(F)),i+=A.length,a.push(A)}}this[Pe]=Buffer.concat(a);let c=n&&n.type!==void 0&&String(n.type).toLowerCase();c&&!/[^\u0020-\u007E]/.test(c)&&(this[Ye]=c)}get size(){return this[Pe].length}get type(){return this[Ye]}text(){return Promise.resolve(this[Pe].toString())}arrayBuffer(){const e=this[Pe],n=e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength);return Promise.resolve(n)}stream(){const e=new Le;return e._read=function(){},e.push(this[Pe]),e.push(null),e}toString(){return"[object Blob]"}slice(){const e=this.size,n=arguments[0],a=arguments[1];let i,c;n===void 0?i=0:n<0?i=Math.max(e+n,0):i=Math.min(n,e),a===void 0?c=e:a<0?c=Math.max(e+a,0):c=Math.min(a,e);const d=Math.max(c-i,0),w=this[Pe].slice(i,i+d),F=new O([],{type:arguments[2]});return F[Pe]=w,F}}h(O,"Blob"),Object.defineProperties(O.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}}),Object.defineProperty(O.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0});function pe(r,e,n){Error.call(this,r),this.message=r,this.type=e,n&&(this.code=this.errno=n.code),Error.captureStackTrace(this,this.constructor)}h(pe,"FetchError"),pe.prototype=Object.create(Error.prototype),pe.prototype.constructor=pe,pe.prototype.name="FetchError";let k;try{k=require("encoding").convert}catch{}const t=Symbol("Body internals"),l=ce.PassThrough;function u(r){var e=this,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=n.size;let i=a===void 0?0:a;var c=n.timeout;let d=c===void 0?0:c;r==null?r=null:b(r)?r=Buffer.from(r.toString()):$(r)||Buffer.isBuffer(r)||(Object.prototype.toString.call(r)==="[object ArrayBuffer]"?r=Buffer.from(r):ArrayBuffer.isView(r)?r=Buffer.from(r.buffer,r.byteOffset,r.byteLength):r instanceof ce||(r=Buffer.from(String(r)))),this[t]={body:r,disturbed:!1,error:null},this.size=i,this.timeout=d,r instanceof ce&&r.on("error",function(p){const w=p.name==="AbortError"?p:new pe(`Invalid response body while trying to fetch ${e.url}: ${p.message}`,"system",p);e[t].error=w})}h(u,"Body"),u.prototype={get body(){return this[t].body},get bodyUsed(){return this[t].disturbed},arrayBuffer(){return f.call(this).then(function(r){return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)})},blob(){let r=this.headers&&this.headers.get("content-type")||"";return f.call(this).then(function(e){return Object.assign(new O([],{type:r.toLowerCase()}),{[Pe]:e})})},json(){var r=this;return f.call(this).then(function(e){try{return JSON.parse(e.toString())}catch(n){return u.Promise.reject(new pe(`invalid json response body at ${r.url} reason: ${n.message}`,"invalid-json"))}})},text(){return f.call(this).then(function(r){return r.toString()})},buffer(){return f.call(this)},textConverted(){var r=this;return f.call(this).then(function(e){return v(e,r.headers)})}},Object.defineProperties(u.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}}),u.mixIn=function(r){for(const e of Object.getOwnPropertyNames(u.prototype))if(!(e in r)){const n=Object.getOwnPropertyDescriptor(u.prototype,e);Object.defineProperty(r,e,n)}};function f(){var r=this;if(this[t].disturbed)return u.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[t].disturbed=!0,this[t].error)return u.Promise.reject(this[t].error);let e=this.body;if(e===null)return u.Promise.resolve(Buffer.alloc(0));if($(e)&&(e=e.stream()),Buffer.isBuffer(e))return u.Promise.resolve(e);if(!(e instanceof ce))return u.Promise.resolve(Buffer.alloc(0));let n=[],a=0,i=!1;return new u.Promise(function(c,d){let p;r.timeout&&(p=setTimeout(function(){i=!0,d(new pe(`Response timeout while trying to fetch ${r.url} (over ${r.timeout}ms)`,"body-timeout"))},r.timeout)),e.on("error",function(w){w.name==="AbortError"?(i=!0,d(w)):d(new pe(`Invalid response body while trying to fetch ${r.url}: ${w.message}`,"system",w))}),e.on("data",function(w){if(!(i||w===null)){if(r.size&&a+w.length>r.size){i=!0,d(new pe(`content size at ${r.url} over limit: ${r.size}`,"max-size"));return}a+=w.length,n.push(w)}}),e.on("end",function(){if(!i){clearTimeout(p);try{c(Buffer.concat(n,a))}catch(w){d(new pe(`Could not create Buffer from response body for ${r.url}: ${w.message}`,"system",w))}}})})}h(f,"consumeBody");function v(r,e){if(typeof k!="function")throw new Error("The package `encoding` must be installed to use the textConverted() function");const n=e.get("content-type");let a="utf-8",i,c;return n&&(i=/charset=([^;]*)/i.exec(n)),c=r.slice(0,1024).toString(),!i&&c&&(i=/<meta.+?charset=(['"])(.+?)\1/i.exec(c)),!i&&c&&(i=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(c),i||(i=/<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(c),i&&i.pop()),i&&(i=/charset=(.*)/i.exec(i.pop()))),!i&&c&&(i=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(c)),i&&(a=i.pop(),(a==="gb2312"||a==="gbk")&&(a="gb18030")),k(r,"UTF-8",a).toString()}h(v,"convertBody");function b(r){return typeof r!="object"||typeof r.append!="function"||typeof r.delete!="function"||typeof r.get!="function"||typeof r.getAll!="function"||typeof r.has!="function"||typeof r.set!="function"?!1:r.constructor.name==="URLSearchParams"||Object.prototype.toString.call(r)==="[object URLSearchParams]"||typeof r.sort=="function"}h(b,"isURLSearchParams");function $(r){return typeof r=="object"&&typeof r.arrayBuffer=="function"&&typeof r.type=="string"&&typeof r.stream=="function"&&typeof r.constructor=="function"&&typeof r.constructor.name=="string"&&/^(Blob|File)$/.test(r.constructor.name)&&/^(Blob|File)$/.test(r[Symbol.toStringTag])}h($,"isBlob");function x(r){let e,n,a=r.body;if(r.bodyUsed)throw new Error("cannot clone body after it is used");return a instanceof ce&&typeof a.getBoundary!="function"&&(e=new l,n=new l,a.pipe(e),a.pipe(n),r[t].body=e,a=n),a}h(x,"clone");function s(r){return r===null?null:typeof r=="string"?"text/plain;charset=UTF-8":b(r)?"application/x-www-form-urlencoded;charset=UTF-8":$(r)?r.type||null:Buffer.isBuffer(r)||Object.prototype.toString.call(r)==="[object ArrayBuffer]"||ArrayBuffer.isView(r)?null:typeof r.getBoundary=="function"?`multipart/form-data;boundary=${r.getBoundary()}`:r instanceof ce?null:"text/plain;charset=UTF-8"}h(s,"extractContentType");function o(r){const e=r.body;return e===null?0:$(e)?e.size:Buffer.isBuffer(e)?e.length:e&&typeof e.getLengthSync=="function"&&(e._lengthRetrievers&&e._lengthRetrievers.length==0||e.hasKnownLength&&e.hasKnownLength())?e.getLengthSync():null}h(o,"getTotalBytes");function m(r,e){const n=e.body;n===null?r.end():$(n)?n.stream().pipe(r):Buffer.isBuffer(n)?(r.write(n),r.end()):n.pipe(r)}h(m,"writeToStream"),u.Promise=global.Promise;const g=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,C=/[^\t\x20-\x7e\x80-\xff]/;function U(r){if(r=`${r}`,g.test(r)||r==="")throw new TypeError(`${r} is not a legal HTTP header name`)}h(U,"validateName");function N(r){if(r=`${r}`,C.test(r))throw new TypeError(`${r} is not a legal HTTP header value`)}h(N,"validateValue");function T(r,e){e=e.toLowerCase();for(const n in r)if(n.toLowerCase()===e)return n}h(T,"find");const B=Symbol("map");class j{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:void 0;if(this[B]=Object.create(null),e instanceof j){const n=e.raw(),a=Object.keys(n);for(const i of a)for(const c of n[i])this.append(i,c);return}if(e!=null)if(typeof e=="object"){const n=e[Symbol.iterator];if(n!=null){if(typeof n!="function")throw new TypeError("Header pairs must be iterable");const a=[];for(const i of e){if(typeof i!="object"||typeof i[Symbol.iterator]!="function")throw new TypeError("Each header pair must be iterable");a.push(Array.from(i))}for(const i of a){if(i.length!==2)throw new TypeError("Each header pair must be a name/value tuple");this.append(i[0],i[1])}}else for(const a of Object.keys(e)){const i=e[a];this.append(a,i)}}else throw new TypeError("Provided initializer must be an object")}get(e){e=`${e}`,U(e);const n=T(this[B],e);return n===void 0?null:this[B][n].join(", ")}forEach(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0,a=Q(this),i=0;for(;i<a.length;){var c=a[i];const d=c[0],p=c[1];e.call(n,p,d,this),a=Q(this),i++}}set(e,n){e=`${e}`,n=`${n}`,U(e),N(n);const a=T(this[B],e);this[B][a!==void 0?a:e]=[n]}append(e,n){e=`${e}`,n=`${n}`,U(e),N(n);const a=T(this[B],e);a!==void 0?this[B][a].push(n):this[B][e]=[n]}has(e){return e=`${e}`,U(e),T(this[B],e)!==void 0}delete(e){e=`${e}`,U(e);const n=T(this[B],e);n!==void 0&&delete this[B][n]}raw(){return this[B]}keys(){return K(this,"key")}values(){return K(this,"value")}[Symbol.iterator](){return K(this,"key+value")}}h(j,"Headers"),j.prototype.entries=j.prototype[Symbol.iterator],Object.defineProperty(j.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(j.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});function Q(r){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"key+value";return Object.keys(r[B]).sort().map(e==="key"?function(a){return a.toLowerCase()}:e==="value"?function(a){return r[B][a].join(", ")}:function(a){return[a.toLowerCase(),r[B][a].join(", ")]})}h(Q,"getHeaders");const H=Symbol("internal");function K(r,e){const n=Object.create(we);return n[H]={target:r,kind:e,index:0},n}h(K,"createHeadersIterator");const we=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==we)throw new TypeError("Value of `this` is not a HeadersIterator");var r=this[H];const e=r.target,n=r.kind,a=r.index,i=Q(e,n),c=i.length;return a>=c?{value:void 0,done:!0}:(this[H].index=a+1,{value:i[a],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));Object.defineProperty(we,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});function te(r){const e=Object.assign({__proto__:null},r[B]),n=T(r[B],"Host");return n!==void 0&&(e[n]=e[n][0]),e}h(te,"exportNodeCompatibleHeaders");function ge(r){const e=new j;for(const n of Object.keys(r))if(!g.test(n))if(Array.isArray(r[n]))for(const a of r[n])C.test(a)||(e[B][n]===void 0?e[B][n]=[a]:e[B][n].push(a));else C.test(r[n])||(e[B][n]=[r[n]]);return e}h(ge,"createHeadersLenient");const Ce=Symbol("Response internals"),_e=se.STATUS_CODES;class me{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};u.call(this,e,n);const a=n.status||200,i=new j(n.headers);if(e!=null&&!i.has("Content-Type")){const c=s(e);c&&i.append("Content-Type",c)}this[Ce]={url:n.url,status:a,statusText:n.statusText||_e[a],headers:i,counter:n.counter}}get url(){return this[Ce].url||""}get status(){return this[Ce].status}get ok(){return this[Ce].status>=200&&this[Ce].status<300}get redirected(){return this[Ce].counter>0}get statusText(){return this[Ce].statusText}get headers(){return this[Ce].headers}clone(){return new me(x(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected})}}h(me,"Response"),u.mixIn(me.prototype),Object.defineProperties(me.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}}),Object.defineProperty(me.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});const $e=Symbol("Request internals"),Ee=ae.URL||D.URL,Ut=ae.parse,At=ae.format;function at(r){return/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(r)&&(r=new Ee(r).toString()),Ut(r)}h(at,"parseURL");const Tt="destroy"in ce.Readable.prototype;function it(r){return typeof r=="object"&&typeof r[$e]=="object"}h(it,"isRequest");function Lt(r){const e=r&&typeof r=="object"&&Object.getPrototypeOf(r);return!!(e&&e.constructor.name==="AbortSignal")}h(Lt,"isAbortSignal");class qe{constructor(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a;it(e)?a=at(e.url):(e&&e.href?a=at(e.href):a=at(`${e}`),e={});let i=n.method||e.method||"GET";if(i=i.toUpperCase(),(n.body!=null||it(e)&&e.body!==null)&&(i==="GET"||i==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");let c=n.body!=null?n.body:it(e)&&e.body!==null?x(e):null;u.call(this,c,{timeout:n.timeout||e.timeout||0,size:n.size||e.size||0});const d=new j(n.headers||e.headers||{});if(c!=null&&!d.has("Content-Type")){const w=s(c);w&&d.append("Content-Type",w)}let p=it(e)?e.signal:null;if("signal"in n&&(p=n.signal),p!=null&&!Lt(p))throw new TypeError("Expected signal to be an instanceof AbortSignal");this[$e]={method:i,redirect:n.redirect||e.redirect||"follow",headers:d,parsedURL:a,signal:p},this.follow=n.follow!==void 0?n.follow:e.follow!==void 0?e.follow:20,this.compress=n.compress!==void 0?n.compress:e.compress!==void 0?e.compress:!0,this.counter=n.counter||e.counter||0,this.agent=n.agent||e.agent}get method(){return this[$e].method}get url(){return At(this[$e].parsedURL)}get headers(){return this[$e].headers}get redirect(){return this[$e].redirect}get signal(){return this[$e].signal}clone(){return new qe(this)}}h(qe,"Request"),u.mixIn(qe.prototype),Object.defineProperty(qe.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(qe.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0}});function _t(r){const e=r[$e].parsedURL,n=new j(r[$e].headers);if(n.has("Accept")||n.set("Accept","*/*"),!e.protocol||!e.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(e.protocol))throw new TypeError("Only HTTP(S) protocols are supported");if(r.signal&&r.body instanceof ce.Readable&&!Tt)throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");let a=null;if(r.body==null&&/^(POST|PUT)$/i.test(r.method)&&(a="0"),r.body!=null){const c=o(r);typeof c=="number"&&(a=String(c))}a&&n.set("Content-Length",a),n.has("User-Agent")||n.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),r.compress&&!n.has("Accept-Encoding")&&n.set("Accept-Encoding","gzip,deflate");let i=r.agent;return typeof i=="function"&&(i=i(e)),!n.has("Connection")&&!i&&n.set("Connection","close"),Object.assign({},e,{method:r.method,headers:te(n),agent:i})}h(_t,"getNodeRequestOptions");function Ke(r){Error.call(this,r),this.type="aborted",this.message=r,Error.captureStackTrace(this,this.constructor)}h(Ke,"AbortError"),Ke.prototype=Object.create(Error.prototype),Ke.prototype.constructor=Ke,Ke.prototype.name="AbortError";const ut=ae.URL||D.URL,mt=ce.PassThrough,Bt=h(function(e,n){const a=new ut(n).hostname,i=new ut(e).hostname;return a===i||a[a.length-i.length-1]==="."&&a.endsWith(i)},"isDomainOrSubdomain");function Ie(r,e){if(!Ie.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return u.Promise=Ie.Promise,new Ie.Promise(function(n,a){const i=new qe(r,e),c=_t(i),d=(c.protocol==="https:"?Re:se).request,p=i.signal;let w=null;const F=h(function(){let re=new Ke("The user aborted a request.");a(re),i.body&&i.body instanceof ce.Readable&&i.body.destroy(re),!(!w||!w.body)&&w.body.emit("error",re)},"abort");if(p&&p.aborted){F();return}const A=h(function(){F(),ee()},"abortAndFinalize"),G=d(c);let X;p&&p.addEventListener("abort",A);function ee(){G.abort(),p&&p.removeEventListener("abort",A),clearTimeout(X)}h(ee,"finalize"),i.timeout&&G.once("socket",function(q){X=setTimeout(function(){a(new pe(`network timeout at: ${i.url}`,"request-timeout")),ee()},i.timeout)}),G.on("error",function(q){a(new pe(`request to ${i.url} failed, reason: ${q.message}`,"system",q)),ee()}),G.on("response",function(q){clearTimeout(X);const re=ge(q.headers);if(Ie.isRedirect(q.statusCode)){const Ve=re.get("Location");let Te=null;try{Te=Ve===null?null:new ut(Ve,i.url).toString()}catch{if(i.redirect!=="manual"){a(new pe(`uri requested responds with an invalid redirect URL: ${Ve}`,"invalid-redirect")),ee();return}}switch(i.redirect){case"error":a(new pe(`uri requested responds with a redirect, redirect mode is set to error: ${i.url}`,"no-redirect")),ee();return;case"manual":if(Te!==null)try{re.set("Location",Te)}catch(Xe){a(Xe)}break;case"follow":if(Te===null)break;if(i.counter>=i.follow){a(new pe(`maximum redirect reached at: ${i.url}`,"max-redirect")),ee();return}const Me={headers:new j(i.headers),follow:i.follow,counter:i.counter+1,agent:i.agent,compress:i.compress,method:i.method,body:i.body,signal:i.signal,timeout:i.timeout,size:i.size};if(!Bt(i.url,Te))for(const Xe of["authorization","www-authenticate","cookie","cookie2"])Me.headers.delete(Xe);if(q.statusCode!==303&&i.body&&o(i)===null){a(new pe("Cannot follow redirect with body being a readable stream","unsupported-redirect")),ee();return}(q.statusCode===303||(q.statusCode===301||q.statusCode===302)&&i.method==="POST")&&(Me.method="GET",Me.body=void 0,Me.headers.delete("content-length")),n(Ie(new qe(Te,Me))),ee();return}}q.once("end",function(){p&&p.removeEventListener("abort",A)});let ne=q.pipe(new mt);const ye={url:i.url,status:q.statusCode,statusText:q.statusMessage,headers:re,size:i.size,timeout:i.timeout,counter:i.counter},Se=re.get("Content-Encoding");if(!i.compress||i.method==="HEAD"||Se===null||q.statusCode===204||q.statusCode===304){w=new me(ne,ye),n(w);return}const Je={flush:xe.Z_SYNC_FLUSH,finishFlush:xe.Z_SYNC_FLUSH};if(Se=="gzip"||Se=="x-gzip"){ne=ne.pipe(xe.createGunzip(Je)),w=new me(ne,ye),n(w);return}if(Se=="deflate"||Se=="x-deflate"){q.pipe(new mt).once("data",function(Te){(Te[0]&15)===8?ne=ne.pipe(xe.createInflate()):ne=ne.pipe(xe.createInflateRaw()),w=new me(ne,ye),n(w)});return}if(Se=="br"&&typeof xe.createBrotliDecompress=="function"){ne=ne.pipe(xe.createBrotliDecompress()),w=new me(ne,ye),n(w);return}w=new me(ne,ye),n(w)}),m(G,i)})}h(Ie,"fetch"),Ie.isRedirect=function(r){return r===301||r===302||r===303||r===307||r===308},Ie.Promise=global.Promise;const pt=Ie;class lt extends Error{constructor(e){super(e);Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="Deprecation"}}h(lt,"Deprecation");var Dt=E(778),vt=E.n(Dt);const Mt=vt()(r=>console.warn(r)),qt=vt()(r=>console.warn(r));class ke extends Error{constructor(e,n,a){super(e);Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="HttpError",this.status=n;let i;"headers"in a&&typeof a.headers<"u"&&(i=a.headers),"response"in a&&(this.response=a.response,i=a.response.headers);const c=Object.assign({},a.request);a.request.headers.authorization&&(c.headers=Object.assign({},a.request.headers,{authorization:a.request.headers.authorization.replace(/ .*$/," [REDACTED]")})),c.url=c.url.replace(/\bclient_secret=\w+/g,"client_secret=[REDACTED]").replace(/\baccess_token=\w+/g,"access_token=[REDACTED]"),this.request=c,Object.defineProperty(this,"code",{get(){return Mt(new lt("[@octokit/request-error] `error.code` is deprecated, use `error.status`.")),n}}),Object.defineProperty(this,"headers",{get(){return qt(new lt("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.")),i||{}}})}}h(ke,"RequestError");const It="5.6.3";function Nt(r){return r.arrayBuffer()}h(Nt,"getBufferResponse");function yt(r){const e=r.request&&r.request.log?r.request.log:console;(y(r.body)||Array.isArray(r.body))&&(r.body=JSON.stringify(r.body));let n={},a,i;return(r.request&&r.request.fetch||pt)(r.url,Object.assign({method:r.method,body:r.body,headers:r.headers,redirect:r.redirect},r.request)).then(async d=>{i=d.url,a=d.status;for(const p of d.headers)n[p[0]]=p[1];if("deprecation"in n){const p=n.link&&n.link.match(/<([^>]+)>; rel="deprecation"/),w=p&&p.pop();e.warn(`[@octokit/request] "${r.method} ${r.url}" is deprecated. It is scheduled to be removed on ${n.sunset}${w?`. See ${w}`:""}`)}if(!(a===204||a===205)){if(r.method==="HEAD"){if(a<400)return;throw new ke(d.statusText,a,{response:{url:i,status:a,headers:n,data:void 0},request:r})}if(a===304)throw new ke("Not modified",a,{response:{url:i,status:a,headers:n,data:await ct(d)},request:r});if(a>=400){const p=await ct(d);throw new ke(jt(p),a,{response:{url:i,status:a,headers:n,data:p},request:r})}return ct(d)}}).then(d=>({status:a,url:i,headers:n,data:d})).catch(d=>{throw d instanceof ke?d:new ke(d.message,500,{request:r})})}h(yt,"fetchWrapper");async function ct(r){const e=r.headers.get("content-type");return/application\/json/.test(e)?r.json():!e||/^text\/|charset=utf-8$/.test(e)?r.text():Nt(r)}h(ct,"getResponseData");function jt(r){return typeof r=="string"?r:"message"in r?Array.isArray(r.errors)?`${r.message}: ${r.errors.map(JSON.stringify).join(", ")}`:r.message:`Unknown error: ${JSON.stringify(r)}`}h(jt,"toErrorMessage");function ht(r,e){const n=r.defaults(e);return Object.assign(h(function(i,c){const d=n.merge(i,c);if(!d.request||!d.request.hook)return yt(n.parse(d));const p=h((w,F)=>yt(n.parse(n.merge(w,F))),"request");return Object.assign(p,{endpoint:n,defaults:ht.bind(null,n)}),d.request.hook(p,d)},"newApi"),{endpoint:n,defaults:ht.bind(null,n)})}h(ht,"dist_web_withDefaults");const st=ht(Ge,{headers:{"user-agent":`octokit-request.js/${It} ${P()}`}}),Gt="4.8.0";function Yt(r){return`Request failed due to following response errors:
`+r.errors.map(e=>` - ${e.message}`).join(`
`)}h(Yt,"_buildMessageForResponseErrors");class ft extends Error{constructor(e,n,a){super(Yt(a));this.request=e,this.headers=n,this.response=a,this.name="GraphqlResponseError",this.errors=a.errors,this.data=a.data,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}h(ft,"GraphqlResponseError");const kt=["method","baseUrl","url","headers","request","query","mediaType"],Ht=["query","method","url"],bt=/\/api\/v3\/?$/;function zt(r,e,n){if(n){if(typeof e=="string"&&"query"in n)return Promise.reject(new Error('[@octokit/graphql] "query" cannot be used as variable name'));for(const d in n)if(!!Ht.includes(d))return Promise.reject(new Error(`[@octokit/graphql] "${d}" cannot be used as variable name`))}const a=typeof e=="string"?Object.assign({query:e},n):e,i=Object.keys(a).reduce((d,p)=>kt.includes(p)?(d[p]=a[p],d):(d.variables||(d.variables={}),d.variables[p]=a[p],d),{}),c=a.baseUrl||r.endpoint.DEFAULTS.baseUrl;return bt.test(c)&&(i.url=c.replace(bt,"/api/graphql")),r(i).then(d=>{if(d.data.errors){const p={};for(const w of Object.keys(d.headers))p[w]=d.headers[w];throw new ft(i,p,d.data)}return d.data.data})}h(zt,"graphql");function dt(r,e){const n=r.defaults(e);return Object.assign(h((i,c)=>zt(n,i,c),"newApi"),{defaults:dt.bind(null,n),endpoint:st.endpoint})}h(dt,"graphql_dist_web_withDefaults");const hr=dt(st,{headers:{"user-agent":`octokit-graphql.js/${Gt} ${P()}`},method:"POST",url:"/graphql"});function Vt(r){return dt(r,{method:"POST",url:"/graphql"})}h(Vt,"withCustomRequest");const Wt=/^v1\./,Jt=/^ghs_/,Xt=/^ghu_/;async function Qt(r){const e=r.split(/\./).length===3,n=Wt.test(r)||Jt.test(r),a=Xt.test(r);return{type:"token",token:r,tokenType:e?"app":n?"installation":a?"user-to-server":"oauth"}}h(Qt,"auth");function Zt(r){return r.split(/\./).length===3?`bearer ${r}`:`token ${r}`}h(Zt,"withAuthorizationPrefix");async function Kt(r,e,n,a){const i=e.endpoint.merge(n,a);return i.headers.authorization=Zt(r),e(i)}h(Kt,"hook");const er=h(function(e){if(!e)throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");if(typeof e!="string")throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");return e=e.replace(/^(token|bearer) +/i,""),Object.assign(Qt.bind(null,e),{hook:Kt.bind(null,e)})},"createTokenAuth"),wt="3.5.1";class et{constructor(e={}){const n=new Z.Collection,a={baseUrl:st.endpoint.DEFAULTS.baseUrl,headers:{},request:Object.assign({},e.request,{hook:n.bind(null,"request")}),mediaType:{previews:[],format:""}};if(a.headers["user-agent"]=[e.userAgent,`octokit-core.js/${wt} ${P()}`].filter(Boolean).join(" "),e.baseUrl&&(a.baseUrl=e.baseUrl),e.previews&&(a.mediaType.previews=e.previews),e.timeZone&&(a.headers["time-zone"]=e.timeZone),this.request=st.defaults(a),this.graphql=Vt(this.request).defaults(a),this.log=Object.assign({debug:()=>{},info:()=>{},warn:console.warn.bind(console),error:console.error.bind(console)},e.log),this.hook=n,e.authStrategy){const{authStrategy:c,...d}=e,p=c(Object.assign({request:this.request,log:this.log,octokit:this,octokitOptions:d},e.auth));n.wrap("request",p.hook),this.auth=p}else if(!e.auth)this.auth=async()=>({type:"unauthenticated"});else{const c=er(e.auth);n.wrap("request",c.hook),this.auth=c}this.constructor.plugins.forEach(c=>{Object.assign(this,c(this,e))})}static defaults(e){return h(class extends this{constructor(...a){const i=a[0]||{};if(typeof e=="function"){super(e(i));return}super(Object.assign({},e,i,i.userAgent&&e.userAgent?{userAgent:`${i.userAgent} ${e.userAgent}`}:null))}},"OctokitWithDefaults")}static plugin(...e){var n;const a=this.plugins;return n=h(class extends this{},"_a"),n.plugins=a.concat(e.filter(c=>!a.includes(c))),n}}h(et,"Octokit"),et.VERSION=wt,et.plugins=[];var Ct=E(9496),tr=E(4673),Be=E(5396),Oe=E(2833),oe=E(2436),he=E(7369),rr=E(9417),St=Object.defineProperty,nr=Object.defineProperties,ir=Object.getOwnPropertyDescriptor,sr=Object.getOwnPropertyDescriptors,ot=Object.getOwnPropertySymbols,Rt=Object.prototype.hasOwnProperty,xt=Object.prototype.propertyIsEnumerable,gt=h((r,e,n)=>e in r?St(r,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[e]=n,"__defNormalProp"),He=h((r,e)=>{for(var n in e||(e={}))Rt.call(e,n)&&gt(r,n,e[n]);if(ot)for(var n of ot(e))xt.call(e,n)&&gt(r,n,e[n]);return r},"__spreadValues"),ze=h((r,e)=>nr(r,sr(e)),"__spreadProps"),or=h((r,e)=>{var n={};for(var a in r)Rt.call(r,a)&&e.indexOf(a)<0&&(n[a]=r[a]);if(r!=null&&ot)for(var a of ot(r))e.indexOf(a)<0&&xt.call(r,a)&&(n[a]=r[a]);return n},"__objRest"),fe=h((r,e,n,a)=>{for(var i=a>1?void 0:a?ir(e,n):e,c=r.length-1,d;c>=0;c--)(d=r[c])&&(i=(a?d(e,n,i):d(i))||i);return a&&i&&St(e,n,i),i},"__decorateClass"),ar=h((r,e,n)=>(gt(r,typeof e!="symbol"?e+"":e,n),n),"__publicField");const Ae=Object.freeze({values:[]}),$t=Object.freeze({ranges:[]});class ue{constructor(){ar(this,"_octokits",new Map)}async getAccountForCommit(e,n,a,i,c,d){var p,w;const F=oe.Y.getCorrelationContext();try{const A=`query getAccountForCommit(
	$owner: String!
	$repo: String!
	$ref: GitObjectID!
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		object(oid: $ref) {
			... on Commit {
				author {
					name
					email
					avatarUrl(size: $avatarSize)
				}
			}
		}
	}
}`,G=await this.graphql(n,A,ze(He({},d),{owner:a,repo:i,ref:c})),X=(w=(p=G==null?void 0:G.repository)==null?void 0:p.object)==null?void 0:w.author;return X==null?void 0:{provider:e,name:X.name??void 0,email:X.email??void 0,avatarUrl:X.avatarUrl}}catch(A){return this.handleRequestError(A,F,void 0)}}async getAccountForEmail(e,n,a,i,c,d){var p,w;const F=oe.Y.getCorrelationContext();try{const A=`query getAccountForEmail(
	$emailQuery: String!
	$avatarSize: Int
) {
	search(type: USER, query: $emailQuery, first: 1) {
		nodes {
			... on User {
				name
				email
				avatarUrl(size: $avatarSize)
			}
		}
	}
}`,G=await this.graphql(n,A,ze(He({},d),{owner:a,repo:i,emailQuery:`in:email ${c}`})),X=(w=(p=G==null?void 0:G.search)==null?void 0:p.nodes)==null?void 0:w[0];return X==null?void 0:{provider:e,name:X.name??void 0,email:X.email??void 0,avatarUrl:X.avatarUrl}}catch(A){return this.handleRequestError(A,F,void 0)}}async getDefaultBranch(e,n,a,i,c){var d,p;const w=oe.Y.getCorrelationContext();try{const F=`query getDefaultBranch(
	$owner: String!
	$repo: String!
) {
	repository(name: $repo, owner: $owner) {
		defaultBranchRef {
			name
		}
	}
}`,A=await this.graphql(n,F,ze(He({},c),{owner:a,repo:i})),G=((p=(d=A==null?void 0:A.repository)==null?void 0:d.defaultBranchRef)==null?void 0:p.name)??void 0;return G==null?void 0:{provider:e,name:G}}catch(F){return this.handleRequestError(F,w,void 0)}}async getIssueOrPullRequest(e,n,a,i,c,d){var p;const w=oe.Y.getCorrelationContext();try{const F=`query getIssueOrPullRequest(
		$owner: String!
		$repo: String!
		$number: Int!
	) {
		repository(name: $repo, owner: $owner) {
			issueOrPullRequest(number: $number) {
				__typename
				... on Issue {
					createdAt
					closed
					closedAt
					title
					url
				}
				... on PullRequest {
					createdAt
					closed
					closedAt
					title
					url
				}
			}
		}
	}`,A=await this.graphql(n,F,ze(He({},d),{owner:a,repo:i,number:c})),G=(p=A==null?void 0:A.repository)==null?void 0:p.issueOrPullRequest;return G==null?void 0:{provider:e,type:G.type,id:String(c),date:new Date(G.createdAt),title:G.title,closed:G.closed,closedDate:G.closedAt==null?void 0:new Date(G.closedAt),url:G.url}}catch(F){return this.handleRequestError(F,w,void 0)}}async getPullRequestForBranch(e,n,a,i,c,d){var p,w,F,A;const G=oe.Y.getCorrelationContext();try{const X=`query getPullRequestForBranch(
	$owner: String!
	$repo: String!
	$branch: String!
	$limit: Int!
	$include: [PullRequestState!]
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		refs(query: $branch, refPrefix: "refs/heads/", first: 1) {
			nodes {
				associatedPullRequests(first: $limit, orderBy: {field: UPDATED_AT, direction: DESC}, states: $include) {
					nodes {
						author {
							login
							avatarUrl(size: $avatarSize)
							url
						}
						permalink
						number
						title
						state
						updatedAt
						closedAt
						mergedAt
						repository {
							isFork
							owner {
								login
							}
						}
					}
				}
			}
		}
	}
}`,ee=await this.graphql(n,X,ze(He({},d),{owner:a,repo:i,branch:c,limit:10})),q=(A=(F=(w=(p=ee==null?void 0:ee.repository)==null?void 0:p.refs.nodes[0])==null?void 0:w.associatedPullRequests)==null?void 0:F.nodes)==null?void 0:A.filter(re=>!re.repository.isFork||re.repository.owner.login===a);return q==null||q.length===0?void 0:(q.length>1&&q.sort((re,ne)=>(re.repository.owner.login===a?-1:1)-(ne.repository.owner.login===a?-1:1)||(re.state==="OPEN"?-1:1)-(ne.state==="OPEN"?-1:1)||new Date(ne.updatedAt).getTime()-new Date(re.updatedAt).getTime()),tt.from(q[0],e))}catch(X){return this.handleRequestError(X,G,void 0)}}async getPullRequestForCommit(e,n,a,i,c,d){var p,w,F,A;const G=oe.Y.getCorrelationContext();try{const X=`query getPullRequestForCommit(
	$owner: String!
	$repo: String!
	$ref: GitObjectID!
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		object(oid: $ref) {
			... on Commit {
				associatedPullRequests(first: 2, orderBy: {field: UPDATED_AT, direction: DESC}) {
					nodes {
						author {
							login
							avatarUrl(size: $avatarSize)
							url
						}
						permalink
						number
						title
						state
						updatedAt
						closedAt
						mergedAt
						repository {
							isFork
							owner {
								login
							}
						}
					}
				}
			}
		}
	}
}`,ee=await this.graphql(n,X,ze(He({},d),{owner:a,repo:i,ref:c})),q=(A=(F=(w=(p=ee==null?void 0:ee.repository)==null?void 0:p.object)==null?void 0:w.associatedPullRequests)==null?void 0:F.nodes)==null?void 0:A.filter(re=>!re.repository.isFork||re.repository.owner.login===a);return q==null||q.length===0?void 0:(q.length>1&&q.sort((re,ne)=>(re.repository.owner.login===a?-1:1)-(ne.repository.owner.login===a?-1:1)||(re.state==="OPEN"?-1:1)-(ne.state==="OPEN"?-1:1)||new Date(ne.updatedAt).getTime()-new Date(re.updatedAt).getTime()),tt.from(q[0],e))}catch(X){return this.handleRequestError(X,G,void 0)}}async getBlame(e,n,a,i,c){var d,p,w,F,A;const G=oe.Y.getCorrelationContext();try{const X=`query getBlameRanges(
	$owner: String!
	$repo: String!
	$ref: String!
	$path: String!
) {
	viewer { name }
	repository(owner: $owner, name: $repo) {
		object(expression: $ref) {
			...on Commit {
				blame(path: $path) {
					ranges {
						startingLine
						endingLine
						commit {
							oid
							parents(first: 3) { nodes { oid } }
							message
							additions
							changedFiles
							deletions
							author {
								avatarUrl
								date
								email
								name
							}
							committer {
								date
								email
								name
							}
						}
					}
				}
			}
		}
	}
}`,ee=await this.graphql(e,X,{owner:n,repo:a,ref:i,path:c});if(ee==null)return $t;const q=(w=(p=(d=ee.repository)==null?void 0:d.object)==null?void 0:p.blame)==null?void 0:w.ranges;return q==null||q.length===0?{ranges:[],viewer:(F=ee.viewer)==null?void 0:F.name}:{ranges:q,viewer:(A=ee.viewer)==null?void 0:A.name}}catch(X){return this.handleRequestError(X,G,$t)}}async getBranches(e,n,a,i){var c;const d=oe.Y.getCorrelationContext();try{const p=`query getBranches(
	$owner: String!
	$repo: String!
	$branchQuery: String
	$cursor: String
	$limit: Int = 100
) {
	repository(owner: $owner, name: $repo) {
		refs(query: $branchQuery, refPrefix: "refs/heads/", first: $limit, after: $cursor, orderBy: { field: TAG_COMMIT_DATE, direction: DESC }) {
			pageInfo {
				endCursor
				hasNextPage
			}
			nodes {
				name
				target {
					oid
					commitUrl
					...on Commit {
						authoredDate
						committedDate
					}
				}
			}
		}
	}
}`,w=await this.graphql(e,p,{owner:n,repo:a,branchQuery:i==null?void 0:i.query,cursor:i==null?void 0:i.cursor,limit:Math.min(100,(i==null?void 0:i.limit)??100)});if(w==null)return Ae;const F=(c=w.repository)==null?void 0:c.refs;return F==null?Ae:{paging:{cursor:F.pageInfo.endCursor,more:F.pageInfo.hasNextPage},values:F.nodes}}catch(p){return this.handleRequestError(p,d,Ae)}}async getCommit(e,n,a,i){var c,d,p,w,F,A,G,X,ee,q;const re=oe.Y.getCorrelationContext();try{const ne=await this.request(e,"GET /repos/{owner}/{repo}/commits/{ref}",{owner:n,repo:a,ref:i}),ye=ne==null?void 0:ne.data;if(ye==null)return;const{commit:Se}=ye;return{oid:ye.sha,parents:{nodes:ye.parents.map(Je=>({oid:Je.sha}))},message:Se.message,additions:(c=ye.stats)==null?void 0:c.additions,changedFiles:(d=ye.files)==null?void 0:d.length,deletions:(p=ye.stats)==null?void 0:p.deletions,author:{avatarUrl:((w=ye.author)==null?void 0:w.avatar_url)??void 0,date:((F=Se.author)==null?void 0:F.date)??new Date().toString(),email:((A=Se.author)==null?void 0:A.email)??void 0,name:((G=Se.author)==null?void 0:G.name)??""},committer:{date:((X=Se.committer)==null?void 0:X.date)??new Date().toString(),email:((ee=Se.committer)==null?void 0:ee.email)??void 0,name:((q=Se.committer)==null?void 0:q.name)??""},files:ye.files}}catch(ne){return this.handleRequestError(ne,re,void 0)}}async getCommitForFile(e,n,a,i,c){if(Oe.GitRevision.isSha(i))return this.getCommit(e,n,a,i);const d=await this.getCommits(e,n,a,i,{limit:1,path:c});if(d.values.length===0)return;const p=await this.getCommit(e,n,a,d.values[0].oid);return ze(He({},p??d.values[0]),{viewer:d.viewer})}async getCommitBranches(e,n,a,i,c){var d,p;const w=oe.Y.getCorrelationContext();try{const F=`query getCommitBranches(
	$owner: String!
	$repo: String!
	$since: GitTimestamp!
	$until: GitTimestamp!
) {
	repository(owner: $owner, name: $repo) {
		refs(first: 20, refPrefix: "refs/heads/", orderBy: { field: TAG_COMMIT_DATE, direction: DESC }) {
			nodes {
				name
				target {
					... on Commit {
						history(first: 3, since: $since until: $until) {
							nodes { oid }
						}
					}
				}
			}
		}
	}
}`,A=await this.graphql(e,F,{owner:n,repo:a,since:c.toISOString(),until:c.toISOString()}),G=(p=(d=A==null?void 0:A.repository)==null?void 0:d.refs)==null?void 0:p.nodes;if(G==null)return[];const X=[];for(const ee of G)for(const q of ee.target.history.nodes)if(q.oid===i){X.push(ee.name);break}return X}catch(F){return this.handleRequestError(F,w,[])}}async getCommitCount(e,n,a,i){var c,d;const p=oe.Y.getCorrelationContext();try{const w=`query getCommitCount(
	$owner: String!
	$repo: String!
	$ref: String!
) {
	repository(owner: $owner, name: $repo) {
		ref(qualifiedName: $ref) {
			target {
				... on Commit {
					history(first: 1) {
						totalCount
					}
				}
			}
		}
	}
}`,F=await this.graphql(e,w,{owner:n,repo:a,ref:i});return(d=(c=F==null?void 0:F.repository)==null?void 0:c.ref)==null?void 0:d.target.history.totalCount}catch(w){return this.handleRequestError(w,p,void 0)}}async getCommitOnBranch(e,n,a,i,c,d){var p;const w=oe.Y.getCorrelationContext();try{const F=`query getCommitOnBranch(
	$owner: String!
	$repo: String!
	$ref: String!
	$since: GitTimestamp!
	$until: GitTimestamp!
) {
	repository(owner: $owner, name: $repo) {
		ref(qualifiedName: $ref) {
			target {
				... on Commit {
					history(first: 3, since: $since until: $until) {
						nodes { oid }
					}
				}
			}
		}
	}
}`,A=await this.graphql(e,F,{owner:n,repo:a,ref:`refs/heads/${i}`,since:d.toISOString(),until:d.toISOString()}),G=(p=A==null?void 0:A.repository)==null?void 0:p.ref.target.history.nodes;if(G==null)return[];const X=[];for(const ee of G)if(ee.oid===c){X.push(i);break}return X}catch(F){return this.handleRequestError(F,w,[])}}async getCommits(e,n,a,i,c){var d,p,w,F;const A=oe.Y.getCorrelationContext();if((c==null?void 0:c.limit)===1&&(c==null?void 0:c.path)==null)return this.getCommitsCoreSingle(e,n,a,i);try{const G=`query getCommits(
	$owner: String!
	$repo: String!
	$ref: String!
	$path: String
	$author: CommitAuthor
	$after: String
	$before: String
	$limit: Int = 100
	$since: GitTimestamp
	$until: GitTimestamp
) {
	viewer { name }
	repository(name: $repo, owner: $owner) {
		object(expression: $ref) {
			... on Commit {
				history(first: $limit, author: $author, path: $path, after: $after, before: $before, since: $since, until: $until) {
					pageInfo {
						startCursor
						endCursor
						hasNextPage
						hasPreviousPage
					}
					nodes {
						... on Commit {
							oid
							message
							parents(first: 3) { nodes { oid } }
							additions
							changedFiles
							deletions
							author {
								avatarUrl
								date
								email
								name
							}
							committer {
								 date
								 email
								 name
							 }
						}
					}
				}
			}
		}
	}
}`;let X;if((c==null?void 0:c.authors)!=null)if(c.authors.length===1){const[re]=c.authors;X={id:re.id,emails:re.email?[re.email]:void 0}}else{const re=c.authors.filter(ne=>ne.email).map(ne=>ne.email);X=re.length?{emails:re}:void 0}const ee=await this.graphql(e,G,{owner:n,repo:a,ref:i,after:c==null?void 0:c.after,before:c==null?void 0:c.before,path:c==null?void 0:c.path,author:X,limit:Math.min(100,(c==null?void 0:c.limit)??100),since:typeof(c==null?void 0:c.since)=="string"?c==null?void 0:c.since:(d=c==null?void 0:c.since)==null?void 0:d.toISOString(),until:typeof(c==null?void 0:c.until)=="string"?c==null?void 0:c.until:(p=c==null?void 0:c.until)==null?void 0:p.toISOString()}),q=(F=(w=ee==null?void 0:ee.repository)==null?void 0:w.object)==null?void 0:F.history;return q==null?Ae:{paging:q.pageInfo.endCursor!=null?{cursor:q.pageInfo.endCursor??void 0,more:q.pageInfo.hasNextPage}:void 0,values:q.nodes,viewer:ee==null?void 0:ee.viewer.name}}catch(G){return this.handleRequestError(G,A,Ae)}}async getCommitsCoreSingle(e,n,a,i){var c;const d=oe.Y.getCorrelationContext();try{const p=`query getCommit(
	$owner: String!
	$repo: String!
	$ref: String!
) {
	viewer { name }
	repository(name: $repo owner: $owner) {
		object(expression: $ref) {
			...on Commit {
				oid
				parents(first: 3) { nodes { oid } }
				message
				additions
				changedFiles
				deletions
				author {
					avatarUrl
					date
					email
					name
				}
				committer {
					date
					email
					name
				}
			}
		}
	}
}`,w=await this.graphql(e,p,{owner:n,repo:a,ref:i});if(w==null)return Ae;const F=(c=w.repository)==null?void 0:c.object;return F!=null?{values:[F],viewer:w.viewer.name}:Ae}catch(p){return this.handleRequestError(p,d,Ae)}}async getCommitRefs(e,n,a,i,c){var d,p;const w=oe.Y.getCorrelationContext();try{const F=`query getCommitRefs(
	$owner: String!
	$repo: String!
	$ref: String!
	$after: String
	$before: String
	$first: Int
	$last: Int
	$path: String
	$since: GitTimestamp
	$until: GitTimestamp
) {
	repository(name: $repo, owner: $owner) {
		object(expression: $ref) {
			... on Commit {
				history(first: $first, last: $last, path: $path, since: $since, until: $until, after: $after, before: $before) {
					pageInfo { startCursor, endCursor, hasNextPage, hasPreviousPage }
					totalCount
					nodes { oid }
				}
			}
		}
	}
}`,A=await this.graphql(e,F,{owner:n,repo:a,ref:i,path:c==null?void 0:c.path,first:c==null?void 0:c.first,last:c==null?void 0:c.last,after:c==null?void 0:c.after,before:c==null?void 0:c.before,since:c==null?void 0:c.since,until:c==null?void 0:c.until}),G=(p=(d=A==null?void 0:A.repository)==null?void 0:d.object)==null?void 0:p.history;return G==null?void 0:{pageInfo:G.pageInfo,totalCount:G.totalCount,values:G.nodes}}catch(F){return this.handleRequestError(F,w,void 0)}}async getNextCommitRefs(e,n,a,i,c,d){const p=await this.getCommitDate(e,n,a,d);if(p==null)return[];let w=await this.getCommitRefs(e,n,a,i,{path:c,first:1,since:p});if(w==null)return[];const F=`${w.pageInfo.startCursor.split(" ",1)[0]} ${w.totalCount}`;let A;if([,A]=F.split(" ",2),A=Math.min(parseInt(A,10),5),w=await this.getCommitRefs(e,n,a,i,{path:c,last:A,before:F}),w==null)return[];const G=[];for(const{oid:X}of w.values){if(X===d)break;G.push(X)}return G.reverse()}async getCommitDate(e,n,a,i){var c,d;const p=oe.Y.getCorrelationContext();try{const w=`query getCommitDate(
	$owner: String!
	$repo: String!
	$sha: GitObjectID!
) {
	repository(name: $repo, owner: $owner) {
		object(oid: $sha) {
			... on Commit { committer { date } }
		}
	}
}`,F=await this.graphql(e,w,{owner:n,repo:a,sha:i});return(d=(c=F==null?void 0:F.repository)==null?void 0:c.object)==null?void 0:d.committer.date}catch(w){return this.handleRequestError(w,p,void 0)}}async getContributors(e,n,a){const i=oe.Y.getCorrelationContext();try{const c=await this.request(e,"GET /repos/{owner}/{repo}/contributors",{owner:n,repo:a,per_page:100});return(c==null?void 0:c.data)==null?[]:c.data}catch(c){return this.handleRequestError(c,i,[])}}async getDefaultBranchName(e,n,a){var i,c;const d=oe.Y.getCorrelationContext();try{const p=`query getDefaultBranch(
	$owner: String!
	$repo: String!
) {
	repository(owner: $owner, name: $repo) {
		defaultBranchRef {
			name
		}
	}
}`,w=await this.graphql(e,p,{owner:n,repo:a});return w==null?void 0:((c=(i=w.repository)==null?void 0:i.defaultBranchRef)==null?void 0:c.name)??void 0}catch(p){return this.handleRequestError(p,d,void 0)}}async getCurrentUser(e,n,a){var i,c,d,p;const w=oe.Y.getCorrelationContext();try{const F=`query getCurrentUser(
	$owner: String!
	$repo: String!
) {
	viewer { name, email, login, id }
	repository(owner: $owner, name: $repo) { viewerPermission }
}`,A=await this.graphql(e,F,{owner:n,repo:a});return A==null?void 0:{name:(i=A.viewer)==null?void 0:i.name,email:(c=A.viewer)==null?void 0:c.email,username:(d=A.viewer)==null?void 0:d.login,id:(p=A.viewer)==null?void 0:p.id}}catch(F){return this.handleRequestError(F,w,void 0)}}async getTags(e,n,a,i){var c;const d=oe.Y.getCorrelationContext();try{const p=`query getTags(
	$owner: String!
	$repo: String!
	$tagQuery: String
	$cursor: String
	$limit: Int = 100
) {
	repository(owner: $owner, name: $repo) {
		refs(query: $tagQuery, refPrefix: "refs/tags/", first: $limit, after: $cursor, orderBy: { field: TAG_COMMIT_DATE, direction: DESC }) {
			pageInfo {
				endCursor
				hasNextPage
			}
			nodes {
				name
				target {
					oid
					commitUrl
					...on Commit {
						authoredDate
						committedDate
						message
					}
					...on Tag {
						message
						tagger { date }
					}
				}
			}
		}
	}
}`,w=await this.graphql(e,p,{owner:n,repo:a,tagQuery:i==null?void 0:i.query,cursor:i==null?void 0:i.cursor,limit:Math.min(100,(i==null?void 0:i.limit)??100)});if(w==null)return Ae;const F=(c=w.repository)==null?void 0:c.refs;return F==null?Ae:{paging:{cursor:F.pageInfo.endCursor,more:F.pageInfo.hasNextPage},values:F.nodes}}catch(p){return this.handleRequestError(p,d,Ae)}}async resolveReference(e,n,a,i,c){var d,p,w,F,A,G;const X=oe.Y.getCorrelationContext();try{if(!c){const re=`query resolveReference(
	$owner: String!
	$repo: String!
	$ref: String!
) {
	repository(owner: $owner, name: $repo) {
		object(expression: $ref) {
			oid
		}
	}
}`,ne=await this.graphql(e,re,{owner:n,repo:a,ref:i});return((p=(d=ne==null?void 0:ne.repository)==null?void 0:d.object)==null?void 0:p.oid)??void 0}const ee=`query resolveReference(
	$owner: String!
	$repo: String!
	$ref: String!
	$path: String!
) {
	repository(owner: $owner, name: $repo) {
		object(expression: $ref) {
			... on Commit {
				history(first: 1, path: $path) {
					nodes { oid }
				}
			}
		}
	}
}`,q=await this.graphql(e,ee,{owner:n,repo:a,ref:i,path:c});return((G=(A=(F=(w=q==null?void 0:q.repository)==null?void 0:w.object)==null?void 0:F.history.nodes)==null?void 0:A[0])==null?void 0:G.oid)??void 0}catch(ee){return this.handleRequestError(ee,X,void 0)}}async searchCommits(e,n,a){const i=oe.Y.getCorrelationContext(),c=Math.min(100,(a==null?void 0:a.limit)??100);let d,p,w;(a==null?void 0:a.cursor)!=null?([d,p,w]=a.cursor.split(" ",3),d=parseInt(d,10),p=parseInt(p,10),w=parseInt(w,10)):(d=1,p=c,w=0);try{const F=await this.request(e,"GET /search/commits",{q:n,sort:a==null?void 0:a.sort,order:a==null?void 0:a.order,per_page:p,page:d}),A=F==null?void 0:F.data;if(A==null)return;const G=A.items.map(q=>{var re,ne,ye,Se,Je,Ve,Te,Me,Xe,Ft,Pt,Et,Ot;return{oid:q.sha,parents:{nodes:q.parents.map(lr=>({oid:lr.sha}))},message:q.commit.message,author:{avatarUrl:((re=q.author)==null?void 0:re.avatar_url)??void 0,date:((ne=q.commit.author)==null?void 0:ne.date)??((ye=q.commit.author)==null?void 0:ye.date)??new Date().toString(),email:((Se=q.author)==null?void 0:Se.email)??((Je=q.commit.author)==null?void 0:Je.email)??void 0,name:((Ve=q.author)==null?void 0:Ve.name)??((Te=q.commit.author)==null?void 0:Te.name)??""},committer:{date:((Me=q.commit.committer)==null?void 0:Me.date)??((Xe=q.committer)==null?void 0:Xe.date)??new Date().toString(),email:((Ft=q.committer)==null?void 0:Ft.email)??((Pt=q.commit.committer)==null?void 0:Pt.email)??void 0,name:((Et=q.committer)==null?void 0:Et.name)??((Ot=q.commit.committer)==null?void 0:Ot.name)??""}}}),X=w+A.items.length,ee=A.incomplete_results||A.total_count>X;return{pageInfo:{startCursor:`${d} ${p} ${w}`,endCursor:ee?`${d+1} ${p} ${X}`:void 0,hasPreviousPage:A.total_count>0&&d>1,hasNextPage:ee},totalCount:A.total_count,values:G}}catch(F){return this.handleRequestError(F,i,void 0)}}octokit(e,n){let a=this._octokits.get(e);if(a==null){let i;if(tr.$L){let c=h(function(d,p){if(p.headers!=null){const w=p.headers,{"user-agent":F}=w,A=or(w,["user-agent"]);F&&(p.headers=A)}return pt(d,p)},"fetchCore");i=et.defaults({auth:`token ${e}`,request:{fetch:c}})}else i=et.defaults({auth:`token ${e}`});a=new i(n),this._octokits.set(e,a),(oe.Y.logLevel===oe.i.Debug||oe.Y.isDebugging)&&a.hook.wrap("request",async(c,d)=>{const p=new rr.u(`[GITHUB] ${d.method} ${d.url}`,{log:!1});try{return await c(d)}finally{let w;try{if(typeof d.query=="string"){const F=/(^[^({\n]+)/.exec(d.query);w=` ${(F==null?void 0:F[1].trim())??d.query}`}}catch{}p.stop({message:w})}})}return a}async graphql(e,n,a){var i,c;try{return await this.octokit(e).graphql(n,a)}catch(d){if(d instanceof ft)switch((c=(i=d.errors)==null?void 0:i[0])==null?void 0:c.type){case"NOT_FOUND":throw new Be.Ww(d);case"FORBIDDEN":throw new Be._7("github",Be.Jx.Forbidden,d)}throw Ct.window.showErrorMessage(`Unable to complete GitHub request: ${d.message}`),d}}async request(e,n,a){try{return await this.octokit(e).request(n,a)}catch(i){if(i instanceof ke)switch(i.status){case 404:case 410:case 422:throw new Be.Ww(i);case 401:throw new Be._7("github",Be.Jx.Unauthorized,i);case 403:throw new Be._7("github",Be.Jx.Forbidden,i);case 500:i.response!=null;break;default:if(i.status>=400&&i.status<500)throw new Be.Bn(i);break}throw Ct.window.showErrorMessage(`Unable to complete GitHub request: ${i.message}`),i}}handleRequestError(e,n,a){if(e instanceof Be.Ww)return a;throw oe.Y.error(e,n),e}}h(ue,"GitHubApi"),fe([(0,he.fF)({args:{0:r=>r.name,1:"<token>"}})],ue.prototype,"getAccountForCommit",1),fe([(0,he.fF)({args:{0:r=>r.name,1:"<token>"}})],ue.prototype,"getAccountForEmail",1),fe([(0,he.fF)({args:{0:r=>r.name,1:"<token>"}})],ue.prototype,"getDefaultBranch",1),fe([(0,he.fF)({args:{0:r=>r.name,1:"<token>"}})],ue.prototype,"getIssueOrPullRequest",1),fe([(0,he.fF)({args:{0:r=>r.name,1:"<token>"}})],ue.prototype,"getPullRequestForBranch",1),fe([(0,he.fF)({args:{0:r=>r.name,1:"<token>"}})],ue.prototype,"getPullRequestForCommit",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getBlame",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getBranches",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommit",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommitForFile",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommitBranches",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommitCount",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommitOnBranch",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommits",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCommitRefs",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getNextCommitRefs",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getContributors",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getDefaultBranchName",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getCurrentUser",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"getTags",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"resolveReference",1),fe([(0,he.fF)({args:{0:"<token>"}})],ue.prototype,"searchCommits",1);var tt;(r=>{function e(i,c){return new Oe.PullRequest(c,{name:i.author.login,avatarUrl:i.author.avatarUrl,url:i.author.url},String(i.number),i.title,i.permalink,n(i.state),new Date(i.updatedAt),i.closedAt==null?void 0:new Date(i.closedAt),i.mergedAt==null?void 0:new Date(i.mergedAt))}h(e,"from"),r.from=e;function n(i){return i==="MERGED"?Oe.PullRequestState.Merged:i==="CLOSED"?Oe.PullRequestState.Closed:Oe.PullRequestState.Open}h(n,"fromState"),r.fromState=n;function a(i){return i===Oe.PullRequestState.Merged?"MERGED":i===Oe.PullRequestState.Closed?"CLOSED":"OPEN"}h(a,"toState"),r.toState=a})(tt||(tt={}));function ur(r){switch(r){case"added":return Oe.GitFileIndexStatus.Added;case"changed":case"modified":return Oe.GitFileIndexStatus.Modified;case"removed":return Oe.GitFileIndexStatus.Deleted;case"renamed":return Oe.GitFileIndexStatus.Renamed;case"copied":return Oe.GitFileIndexStatus.Copied}}h(ur,"fromCommitFileStatus")},3760:(W,Y,E)=>{"use strict";E.r(Y),E.d(Y,{GitHubGitProvider:()=>O});var P=E(9496),Z=E(7267),R=E(9179),y=E(1045),M=E(313),S=E(5396),z=E(5059),V=E(2324),_=E(2833),ie=E(7358),J=E(3969),I=E(2436),ve=E(5861),L=E(7369),be=E(2886),de=E(516),Ue=E(2378),Fe=E(1232);async function le(k){try{const t=P.extensions.getExtension("GitHub.remotehub")??P.extensions.getExtension("GitHub.remotehub-insiders");if(t==null)throw I.Y.log("GitHub Repositories extension is not installed or enabled"),new S.R5("GitHub Repositories","GitHub.remotehub");return t.isActive?t.exports:await t.activate()}catch(t){if(I.Y.error(t,"Unable to get required api from the GitHub Repositories extension"),!(t instanceof S.R5),k)return;throw t}}h(le,"getRemoteHubApi");var Qe=(k=>(k[k.Branch=0]="Branch",k[k.RemoteBranch=1]="RemoteBranch",k[k.Tag=2]="Tag",k[k.Commit=3]="Commit",k))(Qe||{}),We=(k=>(k[k.Branch=0]="Branch",k[k.Tag=1]="Tag",k[k.Commit=2]="Commit",k[k.PullRequest=3]="PullRequest",k[k.Tree=4]="Tree",k))(We||{}),Ne=Object.defineProperty,Ze=Object.defineProperties,De=Object.getOwnPropertyDescriptor,rt=Object.getOwnPropertyDescriptors,je=Object.getOwnPropertySymbols,nt=Object.prototype.hasOwnProperty,Ge=Object.prototype.propertyIsEnumerable,ce=h((k,t,l)=>t in k?Ne(k,t,{enumerable:!0,configurable:!0,writable:!0,value:l}):k[t]=l,"__defNormalProp"),se=h((k,t)=>{for(var l in t||(t={}))nt.call(t,l)&&ce(k,l,t[l]);if(je)for(var l of je(t))Ge.call(t,l)&&ce(k,l,t[l]);return k},"__spreadValues"),ae=h((k,t)=>Ze(k,rt(t)),"__spreadProps"),D=h((k,t,l,u)=>{for(var f=u>1?void 0:u?De(t,l):t,v=k.length-1,b;v>=0;v--)(b=k[v])&&(f=(u?b(t,l,f):b(f))||f);return u&&f&&Ne(t,l,f),f},"__decorateClass"),Re=h((k,t,l)=>(ce(k,typeof t!="symbol"?t+"":t,l),l),"__publicField");const xe=Object.freeze({values:[]}),Le=Promise.resolve(void 0),Pe=["repo","read:user","user:email"],Ye=/^[^/](?!.*\/\.)(?!.*\.\.)(?!.*\/\/)(?!.*@\{)[^\000-\037\177 ~^:?*[\\]+[^./]$/;class O{constructor(t){this.container=t,Re(this,"descriptor",{id:z.p.GitHub,name:"GitHub"}),Re(this,"supportedSchemes",new Set([y.sN.Virtual,y.sN.GitHub,y.sN.PRs])),Re(this,"_onDidChangeRepository",new P.EventEmitter),Re(this,"_onDidCloseRepository",new P.EventEmitter),Re(this,"_onDidOpenRepository",new P.EventEmitter),Re(this,"_branchesCache",new Map),Re(this,"_repoInfoCache",new Map),Re(this,"_tagsCache",new Map),Re(this,"_remotehub"),Re(this,"_remotehubPromise"),Re(this,"_sessionPromise")}get onDidChangeRepository(){return this._onDidChangeRepository.event}get onDidCloseRepository(){return this._onDidCloseRepository.event}get onDidOpenRepository(){return this._onDidOpenRepository.event}dispose(){}onRepositoryChanged(t,l){this._branchesCache.delete(t.path),this._tagsCache.delete(t.path),this._repoInfoCache.delete(t.path),this._onDidChangeRepository.fire(l)}async discoverRepositories(t){if(!this.supportedSchemes.has(t.scheme))return[];try{const{remotehub:l}=await this.ensureRepositoryContext(t.toString(),!0),u=l.getVirtualWorkspaceUri(t);return u==null?[]:[this.openRepository(void 0,u,!0)]}catch{return[]}}updateContext(){(0,M.v)(y.zf.HasVirtualFolders,this.container.git.hasOpenRepositories(this.descriptor.id))}openRepository(t,l,u,f,v){return new _.Repository(this.container,this.onRepositoryChanged.bind(this),this.descriptor,t,l,u,f??!P.window.state.focused,v)}async getOpenScmRepositories(){return[]}async getOrOpenScmRepository(t){}canHandlePathOrUri(t,l){if(!!this.supportedSchemes.has(t))return typeof l=="string"?l:l.toString()}getAbsoluteUri(t,l){if(typeof l=="string")if((0,de.tE)(l))l=P.Uri.parse(l,!0);else throw P.window.showErrorMessage(`Unable to get absolute uri between ${typeof t=="string"?t:t.toString(!1)} and ${l}; Base path '${l}' must be a uri`),new Error(`Base path '${l}' must be a uri`);if(typeof t=="string"&&!(0,de.tE)(t)&&!(0,de.YP)(t))return P.Uri.joinPath(l,(0,de.AH)(t));const u=this.getRelativePath(t,l);return P.Uri.joinPath(l,u)}async getBestRevisionUri(t,l,u){return u?this.createProviderUri(t,u,l):this.createVirtualUri(t,u,l)}getRelativePath(t,l){if(typeof l=="string")if((0,de.tE)(l))l=P.Uri.parse(l,!0);else throw P.window.showErrorMessage(`Unable to get relative path between ${typeof t=="string"?t:t.toString(!1)} and ${l}; Base path '${l}' must be a uri`),new Error(`Base path '${l}' must be a uri`);let u;if(typeof t=="string")if((0,de.tE)(t))t=P.Uri.parse(t,!0);else return t=(0,de.AH)(t),u=(0,de.YP)(t)&&t.startsWith(l.path)?t.slice(l.path.length):t,u.charCodeAt(0)===y.mN.Slash&&(u=u.slice(1)),u;return u=(0,de.AH)((0,de.Gf)(l.path.slice(1),t.path.slice(1))),u}getRevisionUri(t,l,u){const f=this.createProviderUri(t,u,l);return u===_.GitRevision.deletedOrMissing?f.with({query:"~"}):f}async getWorkingUri(t,l){return this.createVirtualUri(t,void 0,l.path)}async addRemote(t,l,u){}async pruneRemote(t,l){}async applyChangesToWorkingFile(t,l,u){}async branchContainsCommit(t,l,u){return!1}async checkout(t,l,u){}resetCaches(...t){(t.length===0||t.includes("branches"))&&this._branchesCache.clear(),(t.length===0||t.includes("tags"))&&this._tagsCache.clear(),t.length===0&&this._repoInfoCache.clear()}async excludeIgnoredUris(t,l){return l}async fetch(t,l){}async findRepositoryUri(t,l){const u=I.Y.getCorrelationContext();try{return(await this.ensureRemoteHubApi()).getProviderRootUri(t).with({scheme:y.sN.Virtual})}catch(f){!(f instanceof S.R5),I.Y.error(f,u);return}}async getAheadBehindCommitCount(t,l){}async getBlame(t,l){const u=I.Y.getCorrelationContext();if(l==null?void 0:l.isDirty)return;let f="blame";t.sha!=null&&(f+=`:${t.sha}`);const v=await this.container.tracker.getOrAdd(t);if(v.state!=null){const $=v.state.getBlame(f);if($!=null)return I.Y.debug(u,`Cache hit: '${f}'`),$.item}I.Y.debug(u,`Cache miss: '${f}'`),v.state==null&&(v.state=new Ue.p2(v.key));const b=this.getBlameCore(t,v,f,u);if(v.state!=null){I.Y.debug(u,`Cache add: '${f}'`);const $={item:b};v.state.setBlame(f,$)}return b}async getBlameCore(t,l,u,f){var v,b;try{const $=await this.ensureRepositoryContext(t.repoPath);if($==null)return;const{metadata:x,github:s,remotehub:o,session:m}=$,g=o.getVirtualUri(o.getProviderRootUri(t)),C=this.getRelativePath(t,g);if(t.scheme===y.sN.Virtual){const[H,K]=await Promise.allSettled([P.workspace.fs.stat(t),P.workspace.fs.stat(t.with({scheme:y.sN.GitHub}))]);if(H.status!=="fulfilled"||K.status!=="fulfilled"||H.value.mtime!==K.value.mtime)return}const U=!t.sha||t.sha==="HEAD"?(await x.getRevision()).revision:t.sha,N=await s.getBlame(m==null?void 0:m.accessToken,x.repo.owner,x.repo.name,U,C),T=new Map,B=new Map,j=[];for(const H of N.ranges){const K=H.commit,{viewer:we=m.account.label}=N,te=we!=null&&K.author.name===we?"You":K.author.name,ge=we!=null&&K.committer.name===we?"You":K.committer.name;let Ce=T.get(te);Ce==null&&(Ce={name:te,lineCount:0},T.set(te,Ce)),Ce.lineCount+=H.endingLine-H.startingLine+1;let _e=B.get(K.oid);_e==null&&(_e=new _.GitCommit(this.container,t.repoPath,K.oid,new _.GitCommitIdentity(te,K.author.email,new Date(K.author.date),K.author.avatarUrl),new _.GitCommitIdentity(ge,K.committer.email,new Date(K.author.date)),K.message.split(`
`,1)[0],((v=K.parents.nodes[0])==null?void 0:v.oid)?[(b=K.parents.nodes[0])==null?void 0:b.oid]:[],K.message,new _.GitFileChange(g.toString(),C,_.GitFileIndexStatus.Modified),{changedFiles:K.changedFiles??0,additions:K.additions??0,deletions:K.deletions??0},[]),B.set(K.oid,_e));for(let me=H.startingLine;me<=H.endingLine;me++){const $e={sha:K.oid,originalLine:me,line:me};_e.lines.push($e),j[me-1]=$e}}const Q=new Map([...T.entries()].sort((H,K)=>K[1].lineCount-H[1].lineCount));return{repoPath:t.repoPath,authors:Q,commits:B,lines:j}}catch($){if(l.state!=null&&!/No provider registered with/.test(String($))){const x=($==null?void 0:$.toString())??"";I.Y.debug(f,`Cache replace (with empty promise): '${u}'`);const s={item:Le,errorMessage:x};return l.state.setBlame(u,s),l.setBlameFailure(),Le}return}}async getBlameContents(t,l){}async getBlameForLine(t,l,u,f){var v,b;const $=I.Y.getCorrelationContext();if(!(u==null?void 0:u.isDirty)){if(!(f==null?void 0:f.forceSingleLine)){const x=await this.getBlame(t);if(x==null)return;let s=x.lines[l];if(s==null){if(x.lines.length!==l)return;s=x.lines[l-1]}const o=x.commits.get(s.sha);if(o==null)return;const m=x.authors.get(o.author.name);return{author:ae(se({},m),{lineCount:o.lines.length}),commit:o,line:s}}try{const x=await this.ensureRepositoryContext(t.repoPath);if(x==null)return;const{metadata:s,github:o,remotehub:m,session:g}=x,C=m.getVirtualUri(m.getProviderRootUri(t)),U=this.getRelativePath(t,C),N=!t.sha||t.sha==="HEAD"?(await s.getRevision()).revision:t.sha,T=await o.getBlame(g==null?void 0:g.accessToken,s.repo.owner,s.repo.name,N,U),B=l+1,j=T.ranges.find(ge=>ge.startingLine===B);if(j==null)return;const Q=j.commit,{viewer:H=g.account.label}=T,K=H!=null&&Q.author.name===H?"You":Q.author.name,we=H!=null&&Q.committer.name===H?"You":Q.committer.name,te=new _.GitCommit(this.container,t.repoPath,Q.oid,new _.GitCommitIdentity(K,Q.author.email,new Date(Q.author.date),Q.author.avatarUrl),new _.GitCommitIdentity(we,Q.committer.email,new Date(Q.author.date)),Q.message.split(`
`,1)[0],((v=Q.parents.nodes[0])==null?void 0:v.oid)?[(b=Q.parents.nodes[0])==null?void 0:b.oid]:[],Q.message,new _.GitFileChange(C.toString(),U,_.GitFileIndexStatus.Modified),{changedFiles:Q.changedFiles??0,additions:Q.additions??0,deletions:Q.deletions??0},[]);for(let ge=j.startingLine;ge<=j.endingLine;ge++){const Ce={sha:Q.oid,originalLine:ge,line:ge};te.lines.push(Ce)}return{author:{name:K,lineCount:j.endingLine-j.startingLine+1},commit:te,line:{sha:Q.oid,originalLine:j.startingLine,line:j.startingLine}}}catch(x){I.Y.error($,x);return}}}async getBlameForLineContents(t,l,u,f){}async getBlameForRange(t,l){const u=await this.getBlame(t);if(u!=null)return this.getBlameRange(u,t,l)}async getBlameForRangeContents(t,l,u){const f=await this.getBlameContents(t,u);if(f!=null)return this.getBlameRange(f,t,l)}getBlameRange(t,l,u){if(t.lines.length===0)return se({allLines:t.lines},t);if(u.start.line===0&&u.end.line===t.lines.length-1)return se({allLines:t.lines},t);const f=t.lines.slice(u.start.line,u.end.line+1),v=new Set(f.map(m=>m.sha)),b=u.start.line+1,$=u.end.line+1,x=new Map,s=new Map;for(const m of t.commits.values()){if(!v.has(m.sha))continue;const g=m.with({lines:m.lines.filter(U=>U.line>=b&&U.line<=$)});s.set(m.sha,g);let C=x.get(g.author.name);C==null&&(C={name:g.author.name,lineCount:0},x.set(C.name,C)),C.lineCount+=g.lines.length}const o=new Map([...x.entries()].sort((m,g)=>g[1].lineCount-m[1].lineCount));return{repoPath:l.repoPath,authors:o,commits:s,lines:f,allLines:t.lines}}async getBranch(t){const{values:[l]}=await this.getBranches(t,{filter:u=>u.current});return l}async getBranches(t,l){if(t==null)return xe;const u=I.Y.getCorrelationContext();let f=(l==null?void 0:l.cursor)?void 0:this._branchesCache.get(t);if(f==null){async function b(){var $;try{const{metadata:x,github:s,session:o}=await this.ensureRepositoryContext(t),m=await x.getRevision(),g=m.type===0?m.name:void 0,C=[];let U=l==null?void 0:l.cursor;const N=U==null;for(;;){const T=await s.getBranches(o==null?void 0:o.accessToken,x.repo.owner,x.repo.name,{cursor:U});for(const B of T.values){const j=new Date(this.container.config.advanced.commitOrdering==="author-date"?B.target.authoredDate:B.target.committedDate),Q=B.target.oid;C.push(new _.GitBranch(t,B.name,!1,B.name===g,j,Q,{name:`origin/${B.name}`,missing:!1}),new _.GitBranch(t,`origin/${B.name}`,!0,!1,j,Q))}if(!(($=T.paging)==null?void 0:$.more)||!N)return ae(se({},T),{values:C});U=T.paging.cursor}}catch(x){return I.Y.error(x,u),this._branchesCache.delete(t),xe}}h(b,"load"),f=b.call(this),(l==null?void 0:l.cursor)==null&&this._branchesCache.set(t,f)}let v=await f;return(l==null?void 0:l.filter)!=null&&(v=ae(se({},v),{values:v.values.filter(l.filter)})),(l==null?void 0:l.sort)!=null&&_.GitBranch.sort(v.values,typeof l.sort=="boolean"?void 0:l.sort),v}async getChangedFilesCount(t,l){if(!l)return;const u=await this.getCommit(t,l);if((u==null?void 0:u.stats)==null)return;const{stats:f}=u,v=typeof f.changedFiles=="number"?f.changedFiles:f.changedFiles.added+f.changedFiles.changed+f.changedFiles.deleted;return{additions:f.additions,deletions:f.deletions,changedFiles:v}}async getCommit(t,l){var u;if(t==null)return;const f=I.Y.getCorrelationContext();try{const{metadata:v,github:b,session:$}=await this.ensureRepositoryContext(t),x=await b.getCommit($==null?void 0:$.accessToken,v.repo.owner,v.repo.name,l);if(x==null)return;const{viewer:s=$.account.label}=x,o=s!=null&&x.author.name===s?"You":x.author.name,m=s!=null&&x.committer.name===s?"You":x.committer.name;return new _.GitCommit(this.container,t,x.oid,new _.GitCommitIdentity(o,x.author.email,new Date(x.author.date),x.author.avatarUrl),new _.GitCommitIdentity(m,x.committer.email,new Date(x.committer.date)),x.message.split(`
`,1)[0],x.parents.nodes.map(g=>g.oid),x.message,((u=x.files)==null?void 0:u.map(g=>new _.GitFileChange(t,g.filename??"",(0,Fe.fromCommitFileStatus)(g.status)??_.GitFileIndexStatus.Modified,g.previous_filename,void 0,{additions:g.additions??0,deletions:g.deletions??0,changes:g.changes??0})))??[],{changedFiles:x.changedFiles??0,additions:x.additions??0,deletions:x.deletions??0},[])}catch(v){I.Y.error(v,f);return}}async getCommitBranches(t,l,u){if(t==null||(u==null?void 0:u.commitDate)==null)return[];const f=I.Y.getCorrelationContext();try{const{metadata:v,github:b,session:$}=await this.ensureRepositoryContext(t);let x;return(u==null?void 0:u.branch)?x=await b.getCommitOnBranch($==null?void 0:$.accessToken,v.repo.owner,v.repo.name,u==null?void 0:u.branch,l,u==null?void 0:u.commitDate):x=await b.getCommitBranches($==null?void 0:$.accessToken,v.repo.owner,v.repo.name,l,u==null?void 0:u.commitDate),x}catch(v){return I.Y.error(v,f),[]}}async getCommitCount(t,l){if(t==null)return;const u=I.Y.getCorrelationContext();try{const{metadata:f,github:v,session:b}=await this.ensureRepositoryContext(t);return await v.getCommitCount(b==null?void 0:b.accessToken,f.repo.owner,f.repo.name,l)}catch(f){I.Y.error(f,u);return}}async getCommitForFile(t,l,u){var f;if(t==null)return;const v=I.Y.getCorrelationContext();try{const{metadata:b,github:$,remotehub:x,session:s}=await this.ensureRepositoryContext(t),o=this.getRelativePath(l,x.getProviderRootUri(l)),m=!(u==null?void 0:u.ref)||u.ref==="HEAD"?(await b.getRevision()).revision:u.ref,g=await $.getCommitForFile(s==null?void 0:s.accessToken,b.repo.owner,b.repo.name,m,o);if(g==null)return;const{viewer:C=s.account.label}=g,U=C!=null&&g.author.name===C?"You":g.author.name,N=C!=null&&g.committer.name===C?"You":g.committer.name,T=(f=g.files)==null?void 0:f.map(j=>new _.GitFileChange(t,j.filename??"",(0,Fe.fromCommitFileStatus)(j.status)??_.GitFileIndexStatus.Modified,j.previous_filename,void 0,{additions:j.additions??0,deletions:j.deletions??0,changes:j.changes??0})),B=T==null?void 0:T.find(j=>j.path===o);return new _.GitCommit(this.container,t,g.oid,new _.GitCommitIdentity(U,g.author.email,new Date(g.author.date),g.author.avatarUrl),new _.GitCommitIdentity(N,g.committer.email,new Date(g.committer.date)),g.message.split(`
`,1)[0],g.parents.nodes.map(j=>j.oid),g.message,{file:B,files:T},{changedFiles:g.changedFiles??0,additions:g.additions??0,deletions:g.deletions??0},[])}catch(b){I.Y.error(b,v);return}}async getOldestUnpushedRefForFile(t,l){}async getContributors(t,l){if(t==null)return[];const u=I.Y.getCorrelationContext();try{const{metadata:f,github:v,session:b}=await this.ensureRepositoryContext(t),$=await v.getContributors(b==null?void 0:b.accessToken,f.repo.owner,f.repo.name),x=await this.getCurrentUser(t),s=[];for(const o of $)o.type==="User"&&s.push(new _.GitContributor(t,o.name,o.email,o.contributions,void 0,(0,_.isUserMatch)(x,o.name,o.email,o.login),void 0,o.login,o.avatar_url,o.node_id));return s}catch(f){return I.Y.error(f,u),[]}}async getCurrentUser(t){if(!t)return;const l=I.Y.getCorrelationContext(),u=this._repoInfoCache.get(t);let f=u==null?void 0:u.user;if(f!=null)return f;if(f!==null)try{const{metadata:v,github:b,session:$}=await this.ensureRepositoryContext(t);return f=await b.getCurrentUser($==null?void 0:$.accessToken,v.repo.owner,v.repo.name),this._repoInfoCache.set(t,ae(se({},u),{user:f??null})),f}catch(v){I.Y.error(v,l),this._repoInfoCache.set(t,ae(se({},u),{user:null}));return}}async getDefaultBranchName(t,l){if(t==null)return;const u=I.Y.getCorrelationContext();try{const{metadata:f,github:v,session:b}=await this.ensureRepositoryContext(t);return await v.getDefaultBranchName(b==null?void 0:b.accessToken,f.repo.owner,f.repo.name)}catch(f){I.Y.error(f,u);return}}async getDiffForFile(t,l,u){}async getDiffForFileContents(t,l,u){}async getDiffForLine(t,l,u,f){}async getDiffStatus(t,l,u,f){}async getFileStatusForCommit(t,l,u){if(u===_.GitRevision.deletedOrMissing||_.GitRevision.isUncommitted(u))return;const f=await this.getCommitForFile(t,l,{ref:u});if(f!=null)return f.findFile(l)}async getLastFetchedTimestamp(t){}async getLog(t,l){var u,f,v;if(t==null)return;const b=I.Y.getCorrelationContext(),$=this.getPagingLimit(l==null?void 0:l.limit);try{const{metadata:x,github:s,session:o}=await this.ensureRepositoryContext(t),m=!(l==null?void 0:l.ref)||l.ref==="HEAD"?(await x.getRevision()).revision:l.ref,g=await s.getCommits(o==null?void 0:o.accessToken,x.repo.owner,x.repo.name,m,{all:l==null?void 0:l.all,authors:l==null?void 0:l.authors,after:l==null?void 0:l.cursor,limit:$,since:(l==null?void 0:l.since)?new Date(l.since):void 0}),C=new Map,{viewer:U=o.account.label}=g;for(const T of g.values){const B=U!=null&&T.author.name===U?"You":T.author.name,j=U!=null&&T.committer.name===U?"You":T.committer.name;let Q=C.get(T.oid);Q==null&&(Q=new _.GitCommit(this.container,t,T.oid,new _.GitCommitIdentity(B,T.author.email,new Date(T.author.date),T.author.avatarUrl),new _.GitCommitIdentity(j,T.committer.email,new Date(T.committer.date)),T.message.split(`
`,1)[0],T.parents.nodes.map(H=>H.oid),T.message,(u=T.files)==null?void 0:u.map(H=>new _.GitFileChange(t,H.filename??"",(0,Fe.fromCommitFileStatus)(H.status)??_.GitFileIndexStatus.Modified,H.previous_filename,void 0,{additions:H.additions??0,deletions:H.deletions??0,changes:H.changes??0})),{changedFiles:T.changedFiles??0,additions:T.additions??0,deletions:T.deletions??0},[]),C.set(T.oid,Q))}const N={repoPath:t,commits:C,sha:m,range:void 0,count:C.size,limit:$,hasMore:((f=g.paging)==null?void 0:f.more)??!1,cursor:(v=g.paging)==null?void 0:v.cursor,query:T=>this.getLog(t,ae(se({},l),{limit:T}))};return N.hasMore&&(N.more=this.getLogMoreFn(N,l)),N}catch(x){I.Y.error(x,b);return}}async getLogRefsOnly(t,l){const u=await this.getLog(t,l);if(u!=null)return new Set([...u.commits.values()].map(f=>f.ref))}getLogMoreFn(t,l){return async u=>{const f=u!=null&&typeof u=="object"?u.until:void 0;let v=typeof u=="number"?u:void 0;if(f&&(0,be.G)(t.commits.values(),s=>s.ref===f))return t;v=this.getPagingLimit(v);const b=await this.getLog(t.repoPath,ae(se({},l),{limit:v,cursor:t.cursor}));if(b==null)return ae(se({},t),{hasMore:!1});const $=new Map([...t.commits,...b.commits]),x={repoPath:t.repoPath,commits:$,sha:t.sha,range:void 0,count:$.size,limit:f==null?(t.limit??0)+v:void 0,hasMore:f==null?b.hasMore:!0,cursor:b.cursor,query:t.query};return x.more=this.getLogMoreFn(x,l),x}}async getLogForSearch(t,l,u){var f,v,b;if(t==null)return;const $=I.Y.getCorrelationContext(),x=J.n.parseSearchOperations(l.pattern);let s,o=x.get("commit:");if(o!=null){const C=await this.getCommit(t,o[0]);return C==null?void 0:{repoPath:t,commits:new Map([[C.sha,C]]),sha:C.sha,range:void 0,count:1,limit:1,hasMore:!1}}const m=[];for([s,o]of x.entries())switch(s){case"message:":m.push(...o.map(C=>C.replace(/ /g,"+")));break;case"author:":m.push(...o.map(C=>(C=C.replace(/ /g,"+"),C.startsWith("@")?`author:${C.slice(1)}`:C.startsWith('"@')?`author:"${C.slice(2)}`:C.includes("@")?`author-email:${C}`:`author-name:${C}`)));break}if(m.length===0)return;const g=this.getPagingLimit(u==null?void 0:u.limit);try{const{metadata:C,github:U,session:N}=await this.ensureRepositoryContext(t),T=await U.searchCommits(N==null?void 0:N.accessToken,`repo:${C.repo.owner}/${C.repo.name}+${m.join("+").trim()}`,{cursor:u==null?void 0:u.cursor,limit:g,sort:(u==null?void 0:u.ordering)==="date"?"committer-date":(u==null?void 0:u.ordering)==="author-date"?"author-date":void 0});if(T==null)return;const B=new Map,j=N.account.label;for(const H of T.values){const K=j!=null&&H.author.name===j?"You":H.author.name,we=j!=null&&H.committer.name===j?"You":H.committer.name;let te=B.get(H.oid);te==null&&(te=new _.GitCommit(this.container,t,H.oid,new _.GitCommitIdentity(K,H.author.email,new Date(H.author.date),H.author.avatarUrl),new _.GitCommitIdentity(we,H.committer.email,new Date(H.committer.date)),H.message.split(`
`,1)[0],H.parents.nodes.map(ge=>ge.oid),H.message,(f=H.files)==null?void 0:f.map(ge=>new _.GitFileChange(t,ge.filename??"",(0,Fe.fromCommitFileStatus)(ge.status)??_.GitFileIndexStatus.Modified,ge.previous_filename,void 0,{additions:ge.additions??0,deletions:ge.deletions??0,changes:ge.changes??0})),{changedFiles:H.changedFiles??0,additions:H.additions??0,deletions:H.deletions??0},[]),B.set(H.oid,te))}const Q={repoPath:t,commits:B,sha:void 0,range:void 0,count:B.size,limit:g,hasMore:((v=T.pageInfo)==null?void 0:v.hasNextPage)??!1,cursor:((b=T.pageInfo)==null?void 0:b.endCursor)??void 0,query:H=>this.getLog(t,ae(se({},u),{limit:H}))};return Q.hasMore&&(Q.more=this.getLogForSearchMoreFn(Q,l,u)),Q}catch(C){I.Y.error(C,$);return}}getLogForSearchMoreFn(t,l,u){return async f=>{f=this.getPagingLimit(f);const v=await this.getLogForSearch(t.repoPath,l,ae(se({},u),{limit:f,cursor:t.cursor}));if(v==null)return ae(se({},t),{hasMore:!1});const b=new Map([...t.commits,...v.commits]),$={repoPath:t.repoPath,commits:b,sha:t.sha,range:void 0,count:b.size,limit:(t.limit??0)+f,hasMore:v.hasMore,cursor:v.cursor,query:t.query};return $.more=this.getLogForSearchMoreFn($,l,u),$}}async getLogForFile(t,l,u){if(t==null)return;const f=I.Y.getCorrelationContext(),v=this.getRelativePath(l,t);if(t!=null&&t===v)throw new Error(`File name cannot match the repository path; path=${v}`);u=se({reverse:!1},u),u.renames=!1,u.all=!1;let b="log";u.ref!=null&&(b+=`:${u.ref}`),u.limit=this.getPagingLimit(u==null?void 0:u.limit),u.limit&&(b+=`:n${u.limit}`),u.renames&&(b+=":follow"),u.reverse&&(b+=":reverse"),u.since&&(b+=`:since=${u.since}`),u.skip&&(b+=`:skip${u.skip}`),u.cursor&&(b+=`:cursor=${u.cursor}`);const $=await this.container.tracker.getOrAdd(V.YY.fromFile(v,t,u.ref));if(!u.force&&u.range==null){if($.state!=null){const s=$.state.getLog(b);if(s!=null)return I.Y.debug(f,`Cache hit: '${b}'`),s.item;if(u.ref!=null||u.limit!=null){const o=$.state.getLog(`log${u.renames?":follow":""}${u.reverse?":reverse":""}`);if(o!=null){if(u.ref==null)return I.Y.debug(f,`Cache hit: ~'${b}'`),o.item;I.Y.debug(f,`Cache ?: '${b}'`);let m=await o.item;if(m!=null&&!m.hasMore&&m.commits.has(u.ref)){I.Y.debug(f,`Cache hit: '${b}'`);let g=!0,C=0;const U=new Map((0,be.DZ)(m.commits.entries(),([T,B])=>{if(g){if(T!==(u==null?void 0:u.ref))return;g=!1}if(C++,!((u==null?void 0:u.limit)!=null&&C>u.limit))return[T,B]})),N=se({},u);return m=ae(se({},m),{limit:u.limit,count:U.size,commits:U,query:T=>this.getLogForFile(t,l,ae(se({},N),{limit:T}))}),m}}}}I.Y.debug(f,`Cache miss: '${b}'`),$.state==null&&($.state=new Ue.p2($.key))}const x=this.getLogForFileCore(t,v,$,b,f,u);if($.state!=null&&u.range==null){I.Y.debug(f,`Cache add: '${b}'`);const s={item:x};$.state.setLog(b,s)}return x}async getLogForFileCore(t,l,u,f,v,b){var $,x,s;if(t==null)return;const o=this.getPagingLimit(b==null?void 0:b.limit);try{const m=await this.ensureRepositoryContext(t);if(m==null)return;const{metadata:g,github:C,remotehub:U,session:N}=m,T=this.getAbsoluteUri(l,t),B=this.getRelativePath(T,U.getProviderRootUri(T)),j=!(b==null?void 0:b.ref)||b.ref==="HEAD"?(await g.getRevision()).revision:b.ref,Q=await C.getCommits(N==null?void 0:N.accessToken,g.repo.owner,g.repo.name,j,{all:b==null?void 0:b.all,after:b==null?void 0:b.cursor,path:B,limit:o,since:(b==null?void 0:b.since)?new Date(b.since):void 0}),H=new Map,{viewer:K=N.account.label}=Q;for(const te of Q.values){const ge=K!=null&&te.author.name===K?"You":te.author.name,Ce=K!=null&&te.committer.name===K?"You":te.committer.name;let _e=H.get(te.oid);if(_e==null){const me=($=te.files)==null?void 0:$.map(Ee=>new _.GitFileChange(t,Ee.filename??"",(0,Fe.fromCommitFileStatus)(Ee.status)??_.GitFileIndexStatus.Modified,Ee.previous_filename,void 0,{additions:Ee.additions??0,deletions:Ee.deletions??0,changes:Ee.changes??0})),$e=(0,de.Mh)(B)?void 0:(me==null?void 0:me.find(Ee=>Ee.path===B))??new _.GitFileChange(t,B,_.GitFileIndexStatus.Modified,void 0,void 0,te.changedFiles===1?{additions:te.additions??0,deletions:te.deletions??0,changes:0}:void 0);_e=new _.GitCommit(this.container,t,te.oid,new _.GitCommitIdentity(ge,te.author.email,new Date(te.author.date),te.author.avatarUrl),new _.GitCommitIdentity(Ce,te.committer.email,new Date(te.committer.date)),te.message.split(`
`,1)[0],te.parents.nodes.map(Ee=>Ee.oid),te.message,{file:$e,files:me},{changedFiles:te.changedFiles??0,additions:te.additions??0,deletions:te.deletions??0},[]),H.set(te.oid,_e)}}const we={repoPath:t,commits:H,sha:j,range:void 0,count:H.size,limit:o,hasMore:((x=Q.paging)==null?void 0:x.more)??!1,cursor:(s=Q.paging)==null?void 0:s.cursor,query:te=>this.getLogForFile(t,l,ae(se({},b),{limit:te}))};return we.hasMore&&(we.more=this.getLogForFileMoreFn(we,l,b)),we}catch(m){if(u.state!=null&&(b==null?void 0:b.range)==null&&!(b==null?void 0:b.reverse)){const g=(m==null?void 0:m.toString())??"";I.Y.debug(v,`Cache replace (with empty promise): '${f}'`);const C={item:Le,errorMessage:g};return u.state.setLog(f,C),Le}return}}getLogForFileMoreFn(t,l,u){return async f=>{const v=f!=null&&typeof f=="object"?f.until:void 0;let b=typeof f=="number"?f:void 0;if(v&&(0,be.G)(t.commits.values(),o=>o.ref===v))return t;b=this.getPagingLimit(b);const $=await this.getLogForFile(t.repoPath,l,ae(se({},u),{limit:v==null?b:0,cursor:t.cursor}));if($==null)return ae(se({},t),{hasMore:!1});const x=new Map([...t.commits,...$.commits]),s={repoPath:t.repoPath,commits:x,sha:t.sha,range:t.range,count:x.size,limit:v==null?(t.limit??0)+b:void 0,hasMore:v==null?$.hasMore:!0,cursor:$.cursor,query:t.query};return s.more=this.getLogForFileMoreFn(s,l,u),s}}async getMergeBase(t,l,u,f){}async getMergeStatus(t){}async getRebaseStatus(t){}async getNextComparisonUris(t,l,u,f=0){if(!u)return;const v=I.Y.getCorrelationContext();try{const b=await this.ensureRepositoryContext(t);if(b==null)return;const{metadata:$,github:x,remotehub:s,session:o}=b,m=this.getRelativePath(l,s.getProviderRootUri(l)),g=(await $.getRevision()).revision;u==="HEAD"&&(u=g);const C=await x.getNextCommitRefs(o.accessToken,$.repo.owner,$.repo.name,g,m,u);return{current:f===0?V.YY.fromFile(m,t,u):new V.YY(await this.getBestRevisionUri(t,m,C[f-1])),next:new V.YY(await this.getBestRevisionUri(t,m,C[f]))}}catch(b){throw I.Y.error(b,v),b}}async getPreviousComparisonUris(t,l,u,f=0,v=!1){var b,$;if(u===_.GitRevision.deletedOrMissing)return;const x=I.Y.getCorrelationContext();u===_.GitRevision.uncommitted&&(u=void 0);try{const s=await this.ensureRepositoryContext(t);if(s==null)return;const{metadata:o,github:m,remotehub:g,session:C}=s,U=this.getRelativePath(l,g.getProviderRootUri(l)),N=u!=null?1:0,T=await m.getCommitRefs(C.accessToken,o.repo.owner,o.repo.name,!u||u==="HEAD"?(await o.getRevision()).revision:u,{path:U,first:N+f+1});if(T==null)return;const B=f===0?V.YY.fromFile(U,t,u):new V.YY(await this.getBestRevisionUri(t,U,((b=T.values[N+f-1])==null?void 0:b.oid)??_.GitRevision.deletedOrMissing));return B==null||B.sha===_.GitRevision.deletedOrMissing?void 0:{current:B,previous:new V.YY(await this.getBestRevisionUri(t,U,(($=T.values[N+f])==null?void 0:$.oid)??_.GitRevision.deletedOrMissing))}}catch(s){throw I.Y.error(s,x),s}}async getPreviousComparisonUrisForLine(t,l,u,f,v=0){var b,$;if(f===_.GitRevision.deletedOrMissing)return;const x=I.Y.getCorrelationContext();try{const s=await this.ensureRepositoryContext(t);if(s==null)return;const{remotehub:o}=s;let m=this.getRelativePath(l,o.getProviderRootUri(l)),g=V.YY.fromFile(m,t,f),C=u,U,N=u,T=u;for(let B=0;B<Math.max(0,v)+2;B++){const j=await this.getBlameForLine(U??g,T,void 0,{forceSingleLine:!0});if(j==null)break;f=j.commit.sha,m=((b=j.commit.file)==null?void 0:b.path)??(($=j.commit.file)==null?void 0:$.originalPath)??m,T=j.line.originalLine-1;const Q=V.YY.fromFile(m,t,f);U==null?(U=Q,N=T):(g=U,C=N,U=Q,N=T)}return g==null?void 0:{current:g,previous:U,line:(C??u)+1}}catch(s){throw I.Y.error(s,x),s}}async getIncomingActivity(t,l){}async getRemotes(t,l){if(t==null)return[];const u=(l==null?void 0:l.providers)??ie.c.loadProviders(R.DN.get("remotes",null)),f=P.Uri.parse(t,!0),[,v,b]=f.path.split("/",3),$=`https://github.com/${v}/${b}.git`,x="github.com",s=`${v}/${b}`;return[new _.GitRemote(t,`${x}/${s}`,"origin","https",x,s,ie.c.factory(u)($,x,s),[{type:_.GitRemoteType.Fetch,url:$},{type:_.GitRemoteType.Push,url:$}])]}async getRevisionContent(t,l,u){const f=u?this.createProviderUri(t,u,l):this.createVirtualUri(t,u,l);return P.workspace.fs.readFile(f)}async getStash(t){}async getStatusForFile(t,l){}async getStatusForFiles(t,l){}async getStatusForRepo(t){}async getTags(t,l){if(t==null)return xe;const u=I.Y.getCorrelationContext();let f=(l==null?void 0:l.cursor)?void 0:this._tagsCache.get(t);if(f==null){async function b(){var $,x,s;try{const{metadata:o,github:m,session:g}=await this.ensureRepositoryContext(t),C=[];let U=l==null?void 0:l.cursor;const N=U==null;for(;;){const T=await m.getTags(g==null?void 0:g.accessToken,o.repo.owner,o.repo.name,{cursor:U});for(const B of T.values)C.push(new _.GitTag(t,B.name,B.target.oid,B.target.message??"",new Date(B.target.authoredDate??(($=B.target.tagger)==null?void 0:$.date)),new Date(B.target.committedDate??((x=B.target.tagger)==null?void 0:x.date))));if(!((s=T.paging)==null?void 0:s.more)||!N)return ae(se({},T),{values:C});U=T.paging.cursor}}catch(o){return I.Y.error(o,u),this._tagsCache.delete(t),xe}}h(b,"load"),f=b.call(this),(l==null?void 0:l.cursor)==null&&this._tagsCache.set(t,f)}let v=await f;return(l==null?void 0:l.filter)!=null&&(v=ae(se({},v),{values:v.values.filter(l.filter)})),(l==null?void 0:l.sort)!=null&&_.GitTag.sort(v.values,typeof l.sort=="boolean"?void 0:l.sort),v}async getTreeEntryForRevision(t,l,u){if(t==null||!l)return;if(u==="HEAD"){const b=await this.ensureRepositoryContext(t);if(b==null)return;const $=await b.metadata.getRevision();u=$==null?void 0:$.revision}const f=u?this.createProviderUri(t,u,l):this.createVirtualUri(t,u,l),v=await P.workspace.fs.stat(f);if(v!=null)return{path:this.getRelativePath(f,t),commitSha:u,size:v.size,type:v.type===P.FileType.Directory?"tree":"blob"}}async getTreeForRevision(t,l){if(t==null)return[];if(l==="HEAD"){const b=await this.ensureRepositoryContext(t);if(b==null)return[];const $=await b.metadata.getRevision();l=$==null?void 0:$.revision}const u=l?this.createProviderUri(t,l):this.createVirtualUri(t,l),f=await P.workspace.fs.readDirectory(u);if(f==null)return[];const v=[];for(const[b,$]of f){const x=this.getAbsoluteUri(b,u);v.push({path:this.getRelativePath(b,x),commitSha:l,size:0,type:$===P.FileType.Directory?"tree":"blob"})}return[]}async hasBranchOrTag(t,l){var u,f;const[{values:v},{values:b}]=await Promise.all([this.getBranches(t,{filter:(u=l==null?void 0:l.filter)==null?void 0:u.branches,sort:!1}),this.getTags(t,{filter:(f=l==null?void 0:l.filter)==null?void 0:f.tags,sort:!1})]);return v.length!==0||b.length!==0}async hasCommitBeenPushed(t,l){return!0}isTrackable(t){return this.supportedSchemes.has(t.scheme)}async getDiffTool(t){}async openDiffTool(t,l,u){}async openDirectoryCompare(t,l,u,f){}async resolveReference(t,l,u,f){if(!l||l===_.GitRevision.deletedOrMissing||u==null&&_.GitRevision.isSha(l)||u!=null&&_.GitRevision.isUncommitted(l))return l;let v;if(u!=null)v=this.getRelativePath(u,t);else if(!_.GitRevision.isShaLike(l)||l.endsWith("^3"))return l;const b=await this.ensureRepositoryContext(t);if(b==null)return l;const{metadata:$,github:x,session:s}=b,o=await x.resolveReference(s.accessToken,$.repo.owner,$.repo.name,l,v);return o??(v?_.GitRevision.deletedOrMissing:l)}async validateBranchOrTagName(t,l){return Ye.test(t)}async validateReference(t,l){return!0}async stageFile(t,l){}async stageDirectory(t,l){}async unStageFile(t,l){}async unStageDirectory(t,l){}async stashApply(t,l,u){}async stashDelete(t,l,u){}async stashSave(t,l,u,f){}async ensureRepositoryContext(t,l){let u=P.Uri.parse(t,!0);if(!/^github\+?/.test(u.authority))throw new S.kX(t,S.sh.NotAGitHubRepository);if(!l){const x=this.container.git.getRepository(u);if(x==null)throw new S.kX(t,S.sh.NotAGitHubRepository);u=x.uri}let f=this._remotehub;if(f==null)try{f=await this.ensureRemoteHubApi()}catch(x){throw!(x instanceof S.R5),new S.kX(t,S.sh.RemoteHubApiNotFound,x)}const v=await(f==null?void 0:f.getMetadata(u));if((v==null?void 0:v.provider.id)!=="github")throw new S.kX(t,S.sh.NotAGitHubRepository);let b,$;try{[b,$]=await Promise.all([this.container.github,this.ensureSession()])}catch(x){throw x instanceof S._7?new S.kX(t,x.reason===S.Jx.UserDidNotConsent?S.sh.GitHubAuthenticationDenied:S.sh.GitHubAuthenticationNotFound,x):new S.kX(t)}if(b==null)throw new S.kX(t);return{github:b,metadata:v,remotehub:f,session:$}}async ensureRemoteHubApi(t){if(this._remotehubPromise==null&&(this._remotehubPromise=le(),this._remotehubPromise.then(l=>this._remotehub=l,()=>this._remotehub=void 0)),!t)return this._remotehubPromise;try{return await this._remotehubPromise}catch{return}}async ensureSession(){if(this._sessionPromise==null){async function t(){try{return await P.authentication.getSession("github",Pe,{createIfNone:!0})}catch(l){throw l instanceof Error&&l.message.includes("User did not consent")?new S._7("github",S.Jx.UserDidNotConsent):(I.Y.error(l),new S._7("github",void 0,l))}}h(t,"getSession"),this._sessionPromise=t()}return this._sessionPromise}createVirtualUri(t,l,u){let f;if(typeof l=="string")l&&(_.GitRevision.isSha(l)?f={v:1,ref:{id:l,type:2}}:f={v:1,ref:{id:l,type:4}});else switch(l==null?void 0:l.refType){case"revision":case"stash":f={v:1,ref:{id:l.ref,type:2}};break;case"branch":case"tag":f={v:1,ref:{id:l.name,type:4}};break}if(typeof t=="string"&&(t=P.Uri.parse(t,!0)),u){let v=t.path;v.endsWith("/")&&(v=v.slice(0,-1)),u=this.getRelativePath(u,t),u=`${v}/${u.startsWith("/")?u.slice(0,-1):u}`}return t.with({scheme:y.sN.Virtual,authority:pe("github",f),path:u??t.path})}createProviderUri(t,l,u){const f=this.createVirtualUri(t,l,u);return this._remotehub==null?f.scheme!==y.sN.Virtual?f:f.with({scheme:y.sN.GitHub}):this._remotehub.getProviderUri(f)}getPagingLimit(t){return t=Math.min(100,t??this.container.config.advanced.maxListItems??100),t===0&&(t=100),t}async resolveReferenceCore(t,l,u){var f,v;if(u==null||u==="HEAD")return(await l.getRevision()).revision;if(_.GitRevision.isSha(u))return u;if(_.GitRevision.isRange(u))return;const[b,$]=await Promise.allSettled([this.getBranches(t,{filter:x=>x.name===u}),this.getTags(t,{filter:x=>x.name===u})]);return u=(b.status==="fulfilled"?(f=b.value.values[0])==null?void 0:f.sha:void 0)??($.status==="fulfilled"?(v=$.value.values[0])==null?void 0:v.sha:void 0),u==null,u}}h(O,"GitHubGitProvider"),D([(0,L.cM)()],O.prototype,"getBestRevisionUri",1),D([(0,L.cM)()],O.prototype,"getWorkingUri",1),D([(0,L.cM)()],O.prototype,"addRemote",1),D([(0,L.cM)()],O.prototype,"pruneRemote",1),D([(0,L.cM)()],O.prototype,"applyChangesToWorkingFile",1),D([(0,L.cM)()],O.prototype,"branchContainsCommit",1),D([(0,L.cM)()],O.prototype,"checkout",1),D([(0,L.cM)()],O.prototype,"resetCaches",1),D([(0,L.cM)({args:{1:k=>k.length}})],O.prototype,"excludeIgnoredUris",1),D([(0,L.cM)()],O.prototype,"fetch",1),D([(0,ve.H)(),(0,L.fF)()],O.prototype,"findRepositoryUri",1),D([(0,L.cM)({args:{1:k=>k.join(",")}})],O.prototype,"getAheadBehindCommitCount",1),D([(0,ve.H)(),(0,L.cM)()],O.prototype,"getBlame",1),D([(0,L.cM)({args:{1:"<contents>"}})],O.prototype,"getBlameContents",1),D([(0,ve.H)(),(0,L.cM)()],O.prototype,"getBlameForLine",1),D([(0,L.cM)({args:{2:"<contents>"}})],O.prototype,"getBlameForLineContents",1),D([(0,L.cM)()],O.prototype,"getBlameForRange",1),D([(0,L.cM)({args:{2:"<contents>"}})],O.prototype,"getBlameForRangeContents",1),D([(0,L.cM)({args:{0:"<blame>"}})],O.prototype,"getBlameRange",1),D([(0,L.cM)()],O.prototype,"getBranch",1),D([(0,L.cM)({args:{1:!1}})],O.prototype,"getBranches",1),D([(0,L.cM)()],O.prototype,"getChangedFilesCount",1),D([(0,L.cM)()],O.prototype,"getCommit",1),D([(0,L.cM)()],O.prototype,"getCommitBranches",1),D([(0,L.cM)()],O.prototype,"getCommitCount",1),D([(0,L.cM)()],O.prototype,"getCommitForFile",1),D([(0,L.cM)()],O.prototype,"getOldestUnpushedRefForFile",1),D([(0,L.cM)()],O.prototype,"getContributors",1),D([(0,ve.H)(),(0,L.cM)()],O.prototype,"getCurrentUser",1),D([(0,L.cM)()],O.prototype,"getDefaultBranchName",1),D([(0,L.cM)()],O.prototype,"getDiffForFile",1),D([(0,L.cM)({args:{1:k=>"<contents>"}})],O.prototype,"getDiffForFileContents",1),D([(0,L.cM)()],O.prototype,"getDiffForLine",1),D([(0,L.cM)()],O.prototype,"getDiffStatus",1),D([(0,L.cM)()],O.prototype,"getFileStatusForCommit",1),D([(0,L.cM)()],O.prototype,"getLog",1),D([(0,L.cM)()],O.prototype,"getLogRefsOnly",1),D([(0,L.cM)()],O.prototype,"getLogForSearch",1),D([(0,L.cM)()],O.prototype,"getLogForFile",1),D([(0,L.cM)()],O.prototype,"getMergeBase",1),D([(0,L.cM)()],O.prototype,"getMergeStatus",1),D([(0,L.cM)()],O.prototype,"getRebaseStatus",1),D([(0,L.cM)()],O.prototype,"getNextComparisonUris",1),D([(0,L.cM)()],O.prototype,"getPreviousComparisonUris",1),D([(0,L.cM)()],O.prototype,"getPreviousComparisonUrisForLine",1),D([(0,L.cM)()],O.prototype,"getIncomingActivity",1),D([(0,L.cM)({args:{1:!1}})],O.prototype,"getRemotes",1),D([(0,L.cM)()],O.prototype,"getRevisionContent",1),D([(0,L.cM)()],O.prototype,"getStash",1),D([(0,L.cM)()],O.prototype,"getStatusForFile",1),D([(0,L.cM)()],O.prototype,"getStatusForFiles",1),D([(0,L.cM)()],O.prototype,"getStatusForRepo",1),D([(0,L.cM)({args:{1:!1}})],O.prototype,"getTags",1),D([(0,L.cM)()],O.prototype,"getTreeEntryForRevision",1),D([(0,L.cM)()],O.prototype,"getTreeForRevision",1),D([(0,L.cM)()],O.prototype,"hasBranchOrTag",1),D([(0,L.cM)()],O.prototype,"hasCommitBeenPushed",1),D([(0,L.cM)()],O.prototype,"getDiffTool",1),D([(0,L.cM)()],O.prototype,"openDiffTool",1),D([(0,L.cM)()],O.prototype,"openDirectoryCompare",1),D([(0,L.cM)()],O.prototype,"resolveReference",1),D([(0,L.cM)()],O.prototype,"validateBranchOrTagName",1),D([(0,L.cM)()],O.prototype,"validateReference",1),D([(0,L.cM)()],O.prototype,"stageFile",1),D([(0,L.cM)()],O.prototype,"stageDirectory",1),D([(0,L.cM)()],O.prototype,"unStageFile",1),D([(0,L.cM)()],O.prototype,"unStageDirectory",1),D([(0,L.cM)()],O.prototype,"stashApply",1),D([(0,L.cM)()],O.prototype,"stashDelete",1),D([(0,L.cM)({args:{2:k=>k==null?void 0:k.length}})],O.prototype,"stashSave",1),D([(0,ve.H)()],O.prototype,"ensureRepositoryContext",1);function pe(k,t){return`${k}${t!=null?`+${(0,Z.e)(JSON.stringify(t))}`:""}`}h(pe,"encodeAuthority")},778:(W,Y,E)=>{var P=E(2479);W.exports=P(Z),W.exports.strict=P(R),Z.proto=Z(function(){Object.defineProperty(Function.prototype,"once",{value:function(){return Z(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return R(this)},configurable:!0})});function Z(y){var M=h(function(){return M.called?M.value:(M.called=!0,M.value=y.apply(this,arguments))},"f");return M.called=!1,M}h(Z,"once");function R(y){var M=h(function(){if(M.called)throw new Error(M.onceError);return M.called=!0,M.value=y.apply(this,arguments)},"f"),S=y.name||"Function wrapped with `once`";return M.onceError=S+" shouldn't be called more than once",M.called=!1,M}h(R,"onceStrict")},993:W=>{"use strict";var Y={};W.exports=Y;function E(R){return R<0?-1:1}h(E,"sign");function P(R){return R%1===.5&&(R&1)===0?Math.floor(R):Math.round(R)}h(P,"evenRound");function Z(R,y){y.unsigned||--R;const M=y.unsigned?0:-Math.pow(2,R),S=Math.pow(2,R)-1,z=y.moduloBitLength?Math.pow(2,y.moduloBitLength):Math.pow(2,R),V=y.moduloBitLength?Math.pow(2,y.moduloBitLength-1):Math.pow(2,R-1);return function(_,ie){ie||(ie={});let J=+_;if(ie.enforceRange){if(!Number.isFinite(J))throw new TypeError("Argument is not a finite number");if(J=E(J)*Math.floor(Math.abs(J)),J<M||J>S)throw new TypeError("Argument is not in byte range");return J}if(!isNaN(J)&&ie.clamp)return J=P(J),J<M&&(J=M),J>S&&(J=S),J;if(!Number.isFinite(J)||J===0)return 0;if(J=E(J)*Math.floor(Math.abs(J)),J=J%z,!y.unsigned&&J>=V)return J-z;if(y.unsigned){if(J<0)J+=z;else if(J===-0)return 0}return J}}h(Z,"createNumberConversion"),Y.void=function(){},Y.boolean=function(R){return!!R},Y.byte=Z(8,{unsigned:!1}),Y.octet=Z(8,{unsigned:!0}),Y.short=Z(16,{unsigned:!1}),Y["unsigned short"]=Z(16,{unsigned:!0}),Y.long=Z(32,{unsigned:!1}),Y["unsigned long"]=Z(32,{unsigned:!0}),Y["long long"]=Z(32,{unsigned:!1,moduloBitLength:64}),Y["unsigned long long"]=Z(32,{unsigned:!0,moduloBitLength:64}),Y.double=function(R){const y=+R;if(!Number.isFinite(y))throw new TypeError("Argument is not a finite floating-point value");return y},Y["unrestricted double"]=function(R){const y=+R;if(isNaN(y))throw new TypeError("Argument is NaN");return y},Y.float=Y.double,Y["unrestricted float"]=Y["unrestricted double"],Y.DOMString=function(R,y){return y||(y={}),y.treatNullAsEmptyString&&R===null?"":String(R)},Y.ByteString=function(R,y){const M=String(R);let S;for(let z=0;(S=M.codePointAt(z))!==void 0;++z)if(S>255)throw new TypeError("Argument is not a valid bytestring");return M},Y.USVString=function(R){const y=String(R),M=y.length,S=[];for(let z=0;z<M;++z){const V=y.charCodeAt(z);if(V<55296||V>57343)S.push(String.fromCodePoint(V));else if(56320<=V&&V<=57343)S.push(String.fromCodePoint(65533));else if(z===M-1)S.push(String.fromCodePoint(65533));else{const _=y.charCodeAt(z+1);if(56320<=_&&_<=57343){const ie=V&1023,J=_&1023;S.push(String.fromCodePoint((2<<15)+(2<<9)*ie+J)),++z}else S.push(String.fromCodePoint(65533))}}return S.join("")},Y.Date=function(R,y){if(!(R instanceof Date))throw new TypeError("Argument is not a Date object");if(!isNaN(R))return R},Y.RegExp=function(R,y){return R instanceof RegExp||(R=new RegExp(R)),R}},9718:(W,Y,E)=>{"use strict";const P=E(5341);Y.implementation=h(class{constructor(R){const y=R[0],M=R[1];let S=null;if(M!==void 0&&(S=P.basicURLParse(M),S==="failure"))throw new TypeError("Invalid base URL");const z=P.basicURLParse(y,{baseURL:S});if(z==="failure")throw new TypeError("Invalid URL");this._url=z}get href(){return P.serializeURL(this._url)}set href(R){const y=P.basicURLParse(R);if(y==="failure")throw new TypeError("Invalid URL");this._url=y}get origin(){return P.serializeURLOrigin(this._url)}get protocol(){return this._url.scheme+":"}set protocol(R){P.basicURLParse(R+":",{url:this._url,stateOverride:"scheme start"})}get username(){return this._url.username}set username(R){P.cannotHaveAUsernamePasswordPort(this._url)||P.setTheUsername(this._url,R)}get password(){return this._url.password}set password(R){P.cannotHaveAUsernamePasswordPort(this._url)||P.setThePassword(this._url,R)}get host(){const R=this._url;return R.host===null?"":R.port===null?P.serializeHost(R.host):P.serializeHost(R.host)+":"+P.serializeInteger(R.port)}set host(R){this._url.cannotBeABaseURL||P.basicURLParse(R,{url:this._url,stateOverride:"host"})}get hostname(){return this._url.host===null?"":P.serializeHost(this._url.host)}set hostname(R){this._url.cannotBeABaseURL||P.basicURLParse(R,{url:this._url,stateOverride:"hostname"})}get port(){return this._url.port===null?"":P.serializeInteger(this._url.port)}set port(R){P.cannotHaveAUsernamePasswordPort(this._url)||(R===""?this._url.port=null:P.basicURLParse(R,{url:this._url,stateOverride:"port"}))}get pathname(){return this._url.cannotBeABaseURL?this._url.path[0]:this._url.path.length===0?"":"/"+this._url.path.join("/")}set pathname(R){this._url.cannotBeABaseURL||(this._url.path=[],P.basicURLParse(R,{url:this._url,stateOverride:"path start"}))}get search(){return this._url.query===null||this._url.query===""?"":"?"+this._url.query}set search(R){const y=this._url;if(R===""){y.query=null;return}const M=R[0]==="?"?R.substring(1):R;y.query="",P.basicURLParse(M,{url:y,stateOverride:"query"})}get hash(){return this._url.fragment===null||this._url.fragment===""?"":"#"+this._url.fragment}set hash(R){if(R===""){this._url.fragment=null;return}const y=R[0]==="#"?R.substring(1):R;this._url.fragment="",P.basicURLParse(y,{url:this._url,stateOverride:"fragment"})}toJSON(){return this.href}},"URLImpl")},4328:(W,Y,E)=>{"use strict";const P=E(993),Z=E(9581),R=E(9718),y=Z.implSymbol;function M(S){if(!this||this[y]||!(this instanceof M))throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");if(arguments.length<1)throw new TypeError("Failed to construct 'URL': 1 argument required, but only "+arguments.length+" present.");const z=[];for(let V=0;V<arguments.length&&V<2;++V)z[V]=arguments[V];z[0]=P.USVString(z[0]),z[1]!==void 0&&(z[1]=P.USVString(z[1])),W.exports.setup(this,z)}h(M,"URL"),M.prototype.toJSON=h(function(){if(!this||!W.exports.is(this))throw new TypeError("Illegal invocation");const z=[];for(let V=0;V<arguments.length&&V<0;++V)z[V]=arguments[V];return this[y].toJSON.apply(this[y],z)},"toJSON"),Object.defineProperty(M.prototype,"href",{get(){return this[y].href},set(S){S=P.USVString(S),this[y].href=S},enumerable:!0,configurable:!0}),M.prototype.toString=function(){if(!this||!W.exports.is(this))throw new TypeError("Illegal invocation");return this.href},Object.defineProperty(M.prototype,"origin",{get(){return this[y].origin},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"protocol",{get(){return this[y].protocol},set(S){S=P.USVString(S),this[y].protocol=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"username",{get(){return this[y].username},set(S){S=P.USVString(S),this[y].username=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"password",{get(){return this[y].password},set(S){S=P.USVString(S),this[y].password=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"host",{get(){return this[y].host},set(S){S=P.USVString(S),this[y].host=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"hostname",{get(){return this[y].hostname},set(S){S=P.USVString(S),this[y].hostname=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"port",{get(){return this[y].port},set(S){S=P.USVString(S),this[y].port=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"pathname",{get(){return this[y].pathname},set(S){S=P.USVString(S),this[y].pathname=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"search",{get(){return this[y].search},set(S){S=P.USVString(S),this[y].search=S},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"hash",{get(){return this[y].hash},set(S){S=P.USVString(S),this[y].hash=S},enumerable:!0,configurable:!0}),W.exports={is(S){return!!S&&S[y]instanceof R.implementation},create(S,z){let V=Object.create(M.prototype);return this.setup(V,S,z),V},setup(S,z,V){V||(V={}),V.wrapper=S,S[y]=new R.implementation(z,V),S[y][Z.wrapperSymbol]=S},interface:M,expose:{Window:{URL:M},Worker:{URL:M}}}},7347:(W,Y,E)=>{"use strict";Y.URL=E(4328).interface,E(5341).serializeURL,E(5341).serializeURLOrigin,E(5341).basicURLParse,E(5341).setTheUsername,E(5341).setThePassword,E(5341).serializeHost,E(5341).serializeInteger,E(5341).parseURL},5341:(W,Y,E)=>{"use strict";const P=E(5477),Z=E(5691),R={ftp:21,file:null,gopher:70,http:80,https:443,ws:80,wss:443},y=Symbol("failure");function M(s){return P.ucs2.decode(s).length}h(M,"countSymbols");function S(s,o){const m=s[o];return isNaN(m)?void 0:String.fromCodePoint(m)}h(S,"at");function z(s){return s>=48&&s<=57}h(z,"isASCIIDigit");function V(s){return s>=65&&s<=90||s>=97&&s<=122}h(V,"isASCIIAlpha");function _(s){return V(s)||z(s)}h(_,"isASCIIAlphanumeric");function ie(s){return z(s)||s>=65&&s<=70||s>=97&&s<=102}h(ie,"isASCIIHex");function J(s){return s==="."||s.toLowerCase()==="%2e"}h(J,"isSingleDot");function I(s){return s=s.toLowerCase(),s===".."||s==="%2e."||s===".%2e"||s==="%2e%2e"}h(I,"isDoubleDot");function ve(s,o){return V(s)&&(o===58||o===124)}h(ve,"isWindowsDriveLetterCodePoints");function L(s){return s.length===2&&V(s.codePointAt(0))&&(s[1]===":"||s[1]==="|")}h(L,"isWindowsDriveLetterString");function be(s){return s.length===2&&V(s.codePointAt(0))&&s[1]===":"}h(be,"isNormalizedWindowsDriveLetterString");function de(s){return s.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/)!==-1}h(de,"containsForbiddenHostCodePoint");function Ue(s){return s.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/)!==-1}h(Ue,"containsForbiddenHostCodePointExcludingPercent");function Fe(s){return R[s]!==void 0}h(Fe,"isSpecialScheme");function le(s){return Fe(s.scheme)}h(le,"isSpecial");function Qe(s){return R[s]}h(Qe,"defaultPort");function We(s){let o=s.toString(16).toUpperCase();return o.length===1&&(o="0"+o),"%"+o}h(We,"percentEncode");function Ne(s){const o=new Buffer(s);let m="";for(let g=0;g<o.length;++g)m+=We(o[g]);return m}h(Ne,"utf8PercentEncode");function Ze(s){const o=new Buffer(s),m=[];for(let g=0;g<o.length;++g)o[g]!==37?m.push(o[g]):o[g]===37&&ie(o[g+1])&&ie(o[g+2])?(m.push(parseInt(o.slice(g+1,g+3).toString(),16)),g+=2):m.push(o[g]);return new Buffer(m).toString()}h(Ze,"utf8PercentDecode");function De(s){return s<=31||s>126}h(De,"isC0ControlPercentEncode");const rt=new Set([32,34,35,60,62,63,96,123,125]);function je(s){return De(s)||rt.has(s)}h(je,"isPathPercentEncode");const nt=new Set([47,58,59,61,64,91,92,93,94,124]);function Ge(s){return je(s)||nt.has(s)}h(Ge,"isUserinfoPercentEncode");function ce(s,o){const m=String.fromCodePoint(s);return o(s)?Ne(m):m}h(ce,"percentEncodeChar");function se(s){let o=10;return s.length>=2&&s.charAt(0)==="0"&&s.charAt(1).toLowerCase()==="x"?(s=s.substring(2),o=16):s.length>=2&&s.charAt(0)==="0"&&(s=s.substring(1),o=8),s===""?0:(o===10?/[^0-9]/:o===16?/[^0-9A-Fa-f]/:/[^0-7]/).test(s)?y:parseInt(s,o)}h(se,"parseIPv4Number");function ae(s){const o=s.split(".");if(o[o.length-1]===""&&o.length>1&&o.pop(),o.length>4)return s;const m=[];for(const U of o){if(U==="")return s;const N=se(U);if(N===y)return s;m.push(N)}for(let U=0;U<m.length-1;++U)if(m[U]>255)return y;if(m[m.length-1]>=Math.pow(256,5-m.length))return y;let g=m.pop(),C=0;for(const U of m)g+=U*Math.pow(256,3-C),++C;return g}h(ae,"parseIPv4");function D(s){let o="",m=s;for(let g=1;g<=4;++g)o=String(m%256)+o,g!==4&&(o="."+o),m=Math.floor(m/256);return o}h(D,"serializeIPv4");function Re(s){const o=[0,0,0,0,0,0,0,0];let m=0,g=null,C=0;if(s=P.ucs2.decode(s),s[C]===58){if(s[C+1]!==58)return y;C+=2,++m,g=m}for(;C<s.length;){if(m===8)return y;if(s[C]===58){if(g!==null)return y;++C,++m,g=m;continue}let U=0,N=0;for(;N<4&&ie(s[C]);)U=U*16+parseInt(S(s,C),16),++C,++N;if(s[C]===46){if(N===0||(C-=N,m>6))return y;let T=0;for(;s[C]!==void 0;){let B=null;if(T>0)if(s[C]===46&&T<4)++C;else return y;if(!z(s[C]))return y;for(;z(s[C]);){const j=parseInt(S(s,C));if(B===null)B=j;else{if(B===0)return y;B=B*10+j}if(B>255)return y;++C}o[m]=o[m]*256+B,++T,(T===2||T===4)&&++m}if(T!==4)return y;break}else if(s[C]===58){if(++C,s[C]===void 0)return y}else if(s[C]!==void 0)return y;o[m]=U,++m}if(g!==null){let U=m-g;for(m=7;m!==0&&U>0;){const N=o[g+U-1];o[g+U-1]=o[m],o[m]=N,--m,--U}}else if(g===null&&m!==8)return y;return o}h(Re,"parseIPv6");function xe(s){let o="";const g=Ye(s).idx;let C=!1;for(let U=0;U<=7;++U)if(!(C&&s[U]===0)){if(C&&(C=!1),g===U){o+=U===0?"::":":",C=!0;continue}o+=s[U].toString(16),U!==7&&(o+=":")}return o}h(xe,"serializeIPv6");function Le(s,o){if(s[0]==="[")return s[s.length-1]!=="]"?y:Re(s.substring(1,s.length-1));if(!o)return Pe(s);const m=Ze(s),g=Z.toASCII(m,!1,Z.PROCESSING_OPTIONS.NONTRANSITIONAL,!1);if(g===null||de(g))return y;const C=ae(g);return typeof C=="number"||C===y?C:g}h(Le,"parseHost");function Pe(s){if(Ue(s))return y;let o="";const m=P.ucs2.decode(s);for(let g=0;g<m.length;++g)o+=ce(m[g],De);return o}h(Pe,"parseOpaqueHost");function Ye(s){let o=null,m=1,g=null,C=0;for(let U=0;U<s.length;++U)s[U]!==0?(C>m&&(o=g,m=C),g=null,C=0):(g===null&&(g=U),++C);return C>m&&(o=g,m=C),{idx:o,len:m}}h(Ye,"findLongestZeroSequence");function O(s){return typeof s=="number"?D(s):s instanceof Array?"["+xe(s)+"]":s}h(O,"serializeHost");function pe(s){return s.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g,"")}h(pe,"trimControlChars");function k(s){return s.replace(/\u0009|\u000A|\u000D/g,"")}h(k,"trimTabAndNewline");function t(s){const o=s.path;o.length!==0&&(s.scheme==="file"&&o.length===1&&f(o[0])||o.pop())}h(t,"shortenPath");function l(s){return s.username!==""||s.password!==""}h(l,"includesCredentials");function u(s){return s.host===null||s.host===""||s.cannotBeABaseURL||s.scheme==="file"}h(u,"cannotHaveAUsernamePasswordPort");function f(s){return/^[A-Za-z]:$/.test(s)}h(f,"isNormalizedWindowsDriveLetter");function v(s,o,m,g,C){if(this.pointer=0,this.input=s,this.base=o||null,this.encodingOverride=m||"utf-8",this.stateOverride=C,this.url=g,this.failure=!1,this.parseError=!1,!this.url){this.url={scheme:"",username:"",password:"",host:null,port:null,path:[],query:null,fragment:null,cannotBeABaseURL:!1};const N=pe(this.input);N!==this.input&&(this.parseError=!0),this.input=N}const U=k(this.input);for(U!==this.input&&(this.parseError=!0),this.input=U,this.state=C||"scheme start",this.buffer="",this.atFlag=!1,this.arrFlag=!1,this.passwordTokenSeenFlag=!1,this.input=P.ucs2.decode(this.input);this.pointer<=this.input.length;++this.pointer){const N=this.input[this.pointer],T=isNaN(N)?void 0:String.fromCodePoint(N),B=this["parse "+this.state](N,T);if(B){if(B===y){this.failure=!0;break}}else break}}h(v,"URLStateMachine"),v.prototype["parse scheme start"]=h(function(o,m){if(V(o))this.buffer+=m.toLowerCase(),this.state="scheme";else if(!this.stateOverride)this.state="no scheme",--this.pointer;else return this.parseError=!0,y;return!0},"parseSchemeStart"),v.prototype["parse scheme"]=h(function(o,m){if(_(o)||o===43||o===45||o===46)this.buffer+=m.toLowerCase();else if(o===58){if(this.stateOverride&&(le(this.url)&&!Fe(this.buffer)||!le(this.url)&&Fe(this.buffer)||(l(this.url)||this.url.port!==null)&&this.buffer==="file"||this.url.scheme==="file"&&(this.url.host===""||this.url.host===null))||(this.url.scheme=this.buffer,this.buffer="",this.stateOverride))return!1;this.url.scheme==="file"?((this.input[this.pointer+1]!==47||this.input[this.pointer+2]!==47)&&(this.parseError=!0),this.state="file"):le(this.url)&&this.base!==null&&this.base.scheme===this.url.scheme?this.state="special relative or authority":le(this.url)?this.state="special authority slashes":this.input[this.pointer+1]===47?(this.state="path or authority",++this.pointer):(this.url.cannotBeABaseURL=!0,this.url.path.push(""),this.state="cannot-be-a-base-URL path")}else if(!this.stateOverride)this.buffer="",this.state="no scheme",this.pointer=-1;else return this.parseError=!0,y;return!0},"parseScheme"),v.prototype["parse no scheme"]=h(function(o){return this.base===null||this.base.cannotBeABaseURL&&o!==35?y:(this.base.cannotBeABaseURL&&o===35?(this.url.scheme=this.base.scheme,this.url.path=this.base.path.slice(),this.url.query=this.base.query,this.url.fragment="",this.url.cannotBeABaseURL=!0,this.state="fragment"):this.base.scheme==="file"?(this.state="file",--this.pointer):(this.state="relative",--this.pointer),!0)},"parseNoScheme"),v.prototype["parse special relative or authority"]=h(function(o){return o===47&&this.input[this.pointer+1]===47?(this.state="special authority ignore slashes",++this.pointer):(this.parseError=!0,this.state="relative",--this.pointer),!0},"parseSpecialRelativeOrAuthority"),v.prototype["parse path or authority"]=h(function(o){return o===47?this.state="authority":(this.state="path",--this.pointer),!0},"parsePathOrAuthority"),v.prototype["parse relative"]=h(function(o){return this.url.scheme=this.base.scheme,isNaN(o)?(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(),this.url.query=this.base.query):o===47?this.state="relative slash":o===63?(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(),this.url.query="",this.state="query"):o===35?(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(),this.url.query=this.base.query,this.url.fragment="",this.state="fragment"):le(this.url)&&o===92?(this.parseError=!0,this.state="relative slash"):(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.url.path=this.base.path.slice(0,this.base.path.length-1),this.state="path",--this.pointer),!0},"parseRelative"),v.prototype["parse relative slash"]=h(function(o){return le(this.url)&&(o===47||o===92)?(o===92&&(this.parseError=!0),this.state="special authority ignore slashes"):o===47?this.state="authority":(this.url.username=this.base.username,this.url.password=this.base.password,this.url.host=this.base.host,this.url.port=this.base.port,this.state="path",--this.pointer),!0},"parseRelativeSlash"),v.prototype["parse special authority slashes"]=h(function(o){return o===47&&this.input[this.pointer+1]===47?(this.state="special authority ignore slashes",++this.pointer):(this.parseError=!0,this.state="special authority ignore slashes",--this.pointer),!0},"parseSpecialAuthoritySlashes"),v.prototype["parse special authority ignore slashes"]=h(function(o){return o!==47&&o!==92?(this.state="authority",--this.pointer):this.parseError=!0,!0},"parseSpecialAuthorityIgnoreSlashes"),v.prototype["parse authority"]=h(function(o,m){if(o===64){this.parseError=!0,this.atFlag&&(this.buffer="%40"+this.buffer),this.atFlag=!0;const g=M(this.buffer);for(let C=0;C<g;++C){const U=this.buffer.codePointAt(C);if(U===58&&!this.passwordTokenSeenFlag){this.passwordTokenSeenFlag=!0;continue}const N=ce(U,Ge);this.passwordTokenSeenFlag?this.url.password+=N:this.url.username+=N}this.buffer=""}else if(isNaN(o)||o===47||o===63||o===35||le(this.url)&&o===92){if(this.atFlag&&this.buffer==="")return this.parseError=!0,y;this.pointer-=M(this.buffer)+1,this.buffer="",this.state="host"}else this.buffer+=m;return!0},"parseAuthority"),v.prototype["parse hostname"]=v.prototype["parse host"]=h(function(o,m){if(this.stateOverride&&this.url.scheme==="file")--this.pointer,this.state="file host";else if(o===58&&!this.arrFlag){if(this.buffer==="")return this.parseError=!0,y;const g=Le(this.buffer,le(this.url));if(g===y)return y;if(this.url.host=g,this.buffer="",this.state="port",this.stateOverride==="hostname")return!1}else if(isNaN(o)||o===47||o===63||o===35||le(this.url)&&o===92){if(--this.pointer,le(this.url)&&this.buffer==="")return this.parseError=!0,y;if(this.stateOverride&&this.buffer===""&&(l(this.url)||this.url.port!==null))return this.parseError=!0,!1;const g=Le(this.buffer,le(this.url));if(g===y)return y;if(this.url.host=g,this.buffer="",this.state="path start",this.stateOverride)return!1}else o===91?this.arrFlag=!0:o===93&&(this.arrFlag=!1),this.buffer+=m;return!0},"parseHostName"),v.prototype["parse port"]=h(function(o,m){if(z(o))this.buffer+=m;else if(isNaN(o)||o===47||o===63||o===35||le(this.url)&&o===92||this.stateOverride){if(this.buffer!==""){const g=parseInt(this.buffer);if(g>Math.pow(2,16)-1)return this.parseError=!0,y;this.url.port=g===Qe(this.url.scheme)?null:g,this.buffer=""}if(this.stateOverride)return!1;this.state="path start",--this.pointer}else return this.parseError=!0,y;return!0},"parsePort");const b=new Set([47,92,63,35]);v.prototype["parse file"]=h(function(o){return this.url.scheme="file",o===47||o===92?(o===92&&(this.parseError=!0),this.state="file slash"):this.base!==null&&this.base.scheme==="file"?isNaN(o)?(this.url.host=this.base.host,this.url.path=this.base.path.slice(),this.url.query=this.base.query):o===63?(this.url.host=this.base.host,this.url.path=this.base.path.slice(),this.url.query="",this.state="query"):o===35?(this.url.host=this.base.host,this.url.path=this.base.path.slice(),this.url.query=this.base.query,this.url.fragment="",this.state="fragment"):(this.input.length-this.pointer-1===0||!ve(o,this.input[this.pointer+1])||this.input.length-this.pointer-1>=2&&!b.has(this.input[this.pointer+2])?(this.url.host=this.base.host,this.url.path=this.base.path.slice(),t(this.url)):this.parseError=!0,this.state="path",--this.pointer):(this.state="path",--this.pointer),!0},"parseFile"),v.prototype["parse file slash"]=h(function(o){return o===47||o===92?(o===92&&(this.parseError=!0),this.state="file host"):(this.base!==null&&this.base.scheme==="file"&&(be(this.base.path[0])?this.url.path.push(this.base.path[0]):this.url.host=this.base.host),this.state="path",--this.pointer),!0},"parseFileSlash"),v.prototype["parse file host"]=h(function(o,m){if(isNaN(o)||o===47||o===92||o===63||o===35)if(--this.pointer,!this.stateOverride&&L(this.buffer))this.parseError=!0,this.state="path";else if(this.buffer===""){if(this.url.host="",this.stateOverride)return!1;this.state="path start"}else{let g=Le(this.buffer,le(this.url));if(g===y)return y;if(g==="localhost"&&(g=""),this.url.host=g,this.stateOverride)return!1;this.buffer="",this.state="path start"}else this.buffer+=m;return!0},"parseFileHost"),v.prototype["parse path start"]=h(function(o){return le(this.url)?(o===92&&(this.parseError=!0),this.state="path",o!==47&&o!==92&&--this.pointer):!this.stateOverride&&o===63?(this.url.query="",this.state="query"):!this.stateOverride&&o===35?(this.url.fragment="",this.state="fragment"):o!==void 0&&(this.state="path",o!==47&&--this.pointer),!0},"parsePathStart"),v.prototype["parse path"]=h(function(o){if(isNaN(o)||o===47||le(this.url)&&o===92||!this.stateOverride&&(o===63||o===35)){if(le(this.url)&&o===92&&(this.parseError=!0),I(this.buffer)?(t(this.url),o!==47&&!(le(this.url)&&o===92)&&this.url.path.push("")):J(this.buffer)&&o!==47&&!(le(this.url)&&o===92)?this.url.path.push(""):J(this.buffer)||(this.url.scheme==="file"&&this.url.path.length===0&&L(this.buffer)&&(this.url.host!==""&&this.url.host!==null&&(this.parseError=!0,this.url.host=""),this.buffer=this.buffer[0]+":"),this.url.path.push(this.buffer)),this.buffer="",this.url.scheme==="file"&&(o===void 0||o===63||o===35))for(;this.url.path.length>1&&this.url.path[0]==="";)this.parseError=!0,this.url.path.shift();o===63&&(this.url.query="",this.state="query"),o===35&&(this.url.fragment="",this.state="fragment")}else o===37&&(!ie(this.input[this.pointer+1])||!ie(this.input[this.pointer+2]))&&(this.parseError=!0),this.buffer+=ce(o,je);return!0},"parsePath"),v.prototype["parse cannot-be-a-base-URL path"]=h(function(o){return o===63?(this.url.query="",this.state="query"):o===35?(this.url.fragment="",this.state="fragment"):(!isNaN(o)&&o!==37&&(this.parseError=!0),o===37&&(!ie(this.input[this.pointer+1])||!ie(this.input[this.pointer+2]))&&(this.parseError=!0),isNaN(o)||(this.url.path[0]=this.url.path[0]+ce(o,De))),!0},"parseCannotBeABaseURLPath"),v.prototype["parse query"]=h(function(o,m){if(isNaN(o)||!this.stateOverride&&o===35){(!le(this.url)||this.url.scheme==="ws"||this.url.scheme==="wss")&&(this.encodingOverride="utf-8");const g=new Buffer(this.buffer);for(let C=0;C<g.length;++C)g[C]<33||g[C]>126||g[C]===34||g[C]===35||g[C]===60||g[C]===62?this.url.query+=We(g[C]):this.url.query+=String.fromCodePoint(g[C]);this.buffer="",o===35&&(this.url.fragment="",this.state="fragment")}else o===37&&(!ie(this.input[this.pointer+1])||!ie(this.input[this.pointer+2]))&&(this.parseError=!0),this.buffer+=m;return!0},"parseQuery"),v.prototype["parse fragment"]=h(function(o){return isNaN(o)||(o===0?this.parseError=!0:(o===37&&(!ie(this.input[this.pointer+1])||!ie(this.input[this.pointer+2]))&&(this.parseError=!0),this.url.fragment+=ce(o,De))),!0},"parseFragment");function $(s,o){let m=s.scheme+":";if(s.host!==null?(m+="//",(s.username!==""||s.password!=="")&&(m+=s.username,s.password!==""&&(m+=":"+s.password),m+="@"),m+=O(s.host),s.port!==null&&(m+=":"+s.port)):s.host===null&&s.scheme==="file"&&(m+="//"),s.cannotBeABaseURL)m+=s.path[0];else for(const g of s.path)m+="/"+g;return s.query!==null&&(m+="?"+s.query),!o&&s.fragment!==null&&(m+="#"+s.fragment),m}h($,"serializeURL");function x(s){let o=s.scheme+"://";return o+=O(s.host),s.port!==null&&(o+=":"+s.port),o}h(x,"serializeOrigin"),W.exports.serializeURL=$,W.exports.serializeURLOrigin=function(s){switch(s.scheme){case"blob":try{return W.exports.serializeURLOrigin(W.exports.parseURL(s.path[0]))}catch{return"null"}case"ftp":case"gopher":case"http":case"https":case"ws":case"wss":return x({scheme:s.scheme,host:s.host,port:s.port});case"file":return"file://";default:return"null"}},W.exports.basicURLParse=function(s,o){o===void 0&&(o={});const m=new v(s,o.baseURL,o.encodingOverride,o.url,o.stateOverride);return m.failure?"failure":m.url},W.exports.setTheUsername=function(s,o){s.username="";const m=P.ucs2.decode(o);for(let g=0;g<m.length;++g)s.username+=ce(m[g],Ge)},W.exports.setThePassword=function(s,o){s.password="";const m=P.ucs2.decode(o);for(let g=0;g<m.length;++g)s.password+=ce(m[g],Ge)},W.exports.serializeHost=O,W.exports.cannotHaveAUsernamePasswordPort=u,W.exports.serializeInteger=function(s){return String(s)},W.exports.parseURL=function(s,o){return o===void 0&&(o={}),W.exports.basicURLParse(s,{baseURL:o.baseURL,encodingOverride:o.encodingOverride})}},9581:W=>{"use strict";W.exports.mixin=h(function(E,P){const Z=Object.getOwnPropertyNames(P);for(let R=0;R<Z.length;++R)Object.defineProperty(E,Z[R],Object.getOwnPropertyDescriptor(P,Z[R]))},"mixin"),W.exports.wrapperSymbol=Symbol("wrapper"),W.exports.implSymbol=Symbol("impl"),W.exports.wrapperForImpl=function(Y){return Y[W.exports.wrapperSymbol]},W.exports.implForWrapper=function(Y){return Y[W.exports.implSymbol]}},2479:W=>{W.exports=Y;function Y(E,P){if(E&&P)return Y(E)(P);if(typeof E!="function")throw new TypeError("need wrapper function");return Object.keys(E).forEach(function(R){Z[R]=E[R]}),Z;function Z(){for(var R=new Array(arguments.length),y=0;y<R.length;y++)R[y]=arguments[y];var M=E.apply(this,R),S=R[R.length-1];return typeof M=="function"&&M!==S&&Object.keys(S).forEach(function(z){M[z]=S[z]}),M}h(Z,"wrapper")}h(Y,"wrappy")},5691:W=>{function Y(E){return E}h(Y,"toASCII"),W.exports={toASCII:Y}}};

//# sourceMappingURL=feature-github.js.map